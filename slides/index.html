<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>pathlib: why and how to use it</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <!-- SECTION: intro -->
      <!-- 1 minute -->
      <section>
        <!-- Title slide -->
        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1><code>pathlib.Path</code></h1>
          <h2>Why and how to use it</h2>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            - Today I plan to convince you that you should stop representing your file paths as strings and start using `pathlib` for *all* of your file paths
          </aside>
        </section>

        <!-- About me slide -->
        <section>
          <p class="fragment" data-fragment-index=3 style="margin-bottom: 1em; margin-top: -1em;"><a href="http://trey.io/news" style="color: #663399; font-weight: bold;">trey.io/news</a> ‚Äî  a weekly Python tip üíå</p>
          <div class="aboutme-card fragment" data-fragment-index=1>
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos" alt="Truthful Technology"></a>
          </div>
          <div class="aboutme-card fragment" data-fragment-index=2>
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos" alt="Python Morsels"></a>
          </div>
          <aside class="notes" data-markdown>
            - I help folks level-up their Python skills
            - I run both **(click)** virtual and on-site Python workshops and courses for teams
            - And I run **(click)** Python Morsels, which is a weekly skill-building service for Python developers *all* skill levels
            - I also share **(click)** a Python tip every week through my newsletter, which you can find at trey.io/news
          </aside>
        </section>
      </section>

      <!-- SECTION: os, os.path, glob, shutil -->
      <!-- 4 minutes -->
      <section>

        <section>
          <pre class="python"><code data-trim data-noescape style="font-size: 130%; padding: 0.75em;">
>>> path = "/home/trey/Documents/some_file.txt"
          </code></pre>
          <aside class="notes" data-markdown>
            - For most of Python's history, file paths were represented by strings
            - This still works today and it always will
            - ...
            - Before we really discuss `pathlib`, I'd like to talk about why *this* can be messy
          </aside>
        </section>

        <section>
          <h2>Problems with <em>not</em> using pathlib</h2>
          <ul style="list-style: none; font-size: 1.2em; line-height: 1.5;">
            <li class="fragment" data-fragment-index=1>‚òê <span class="fragment" data-fragment-index=3>Utilities are difficult to find</span></li>
            <li class="fragment" data-fragment-index=1>‚òê <span class="fragment" data-fragment-index=4>Utilities are awkward to use</span></li>
            <li class="fragment" data-fragment-index=2>‚òê <span class="fragment" data-fragment-index=5>String paths are error-prone</span></li>
            <li class="fragment" data-fragment-index=2>‚òê <span class="fragment" data-fragment-index=6>Hard to distinguish paths from other strings</span></li>
          </ul>
          <aside class="notes" data-markdown>
            - There are 4 reasons I recommend using pathlib.
            - 2 of them **(click)** are about the various utilities that pathlib competes with
            - And 2 of them **(click)** are about the problem with representing file paths as strings
            - The alternatives to pathlib are:
              - **(click)** difficult to *find*
              - **(click)** difficult to *use*
            - Also, representing file paths as strings:
              - **(click)** requires *deliberate* effort to *avoid* writing buggy code
              - **(click)** and path strings make it harder to distinguish between *a path* and **any other string**
            - I'd like to address each of these before we talk about pathlib itself
          </aside>
        </section>

        <section style="transform-origin: center center; transform: scale(1.1);">
          <div style="height: 600px; display: grid; grid-template-columns: 1fr 1fr 1fr;">
            <img src="left_shark.jpg" class="fragment no-style" style="margin: auto;" data-fragment-index=5>
            <img src="the_dress.jpg" class="fragment no-style" style="margin: auto;" data-fragment-index=4>
            <div style="position: relative; display: inline-block;" class="fragment" data-fragment-index=2>
            <img src="tiktok_logo.png" class="no-style" style="margin: auto; opacity: 0.8;">
            <!-- Red X overlay -->
            <div style="position: absolute; top: -10%; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0.8;">
                <!-- First diagonal line -->
                <div style="position: absolute; top: 50%; left: 0; width: 100%; height: 10px; background-color: red; transform: translateY(-50%) rotate(45deg); transform-origin: center;"></div>
                <!-- Second diagonal line -->
                <div style="position: absolute; top: 50%; left: 0; width: 100%; height: 10px; background-color: red; transform: translateY(-50%) rotate(-45deg); transform-origin: center;"></div>
            </div>
            </div>
            <img src="old_lateshow_colbert_logo.jpg" class="fragment no-style" style="margin: auto;" data-fragment-index=1>
            <img src="vine_wordmark.svg.png" class="fragment no-style" style="margin: auto;" data-fragment-index=3>
            <img src="pycon_2015.png" class="fragment no-style" style="margin: auto;" data-fragment-index=6>
          </div>
          <aside class="notes" data-markdown>
            - Let's hop in a time machine for a bit...
            - Let's roll the clock back by about 330 million seconds
            - The year is 2015
            - **(click)** The Late Show with Stephen Colbert had just premiered
            - **(click)** TikTok didn't exist, but there was something called **(click)** Vine
            - Everyone's arguing about **(click)** whether the dress is black and blue or white and gold
            - And everyone was preparing **(click)** their left shark Halloween costumes
            - Also we **(click)** were still using Python 2.7, which won't be end-of-life'd for another 5 years
          </aside>
        </section>

        <section>
          <p><code>os</code></p>
          <p><code>os.path</code></p>
          <p><code>glob</code></p>
          <p><code>shutil</code></p>
          <aside class="notes" data-markdown>
            - When we need to work with file paths, there are 4 standard library modules we might reach for...
            - `os`
            - `os.path`
            - `glob`
            - And `shutil`
          </aside>
        </section>

        <section>
          <h1><code>shutil</code> module</h1>
          <p class="fragment highlight-red" data-fragment-index=1><code>copyfile(src, dst)</code>, <code>copyfileobj(fsrc, fdst)</code></p>
          <p class="fragment highlight-red" data-fragment-index=1><code>copy(src, dst)</code>, <code>copy2(src, dst)</code></p>
          <p class="fragment highlight-red" data-fragment-index=1><code>copymode(src, dst)</code>, <code>copystat(src, dst)</code></p>
          <p><code class="fragment highlight-red" data-fragment-index=1>copytree(src, dst)</code>, <code>move(src, dst)</code></p>
          <p><code>rmtree(path)</code></p>
          <p><code>chown(path, ...)</code></p>
          <aside class="notes" data-markdown>
            - The `shutil` module has a bunch of high-level file-related stuff, including **(click)** 7 *different* functions for copying files and directories
          </aside>
        </section>

        <section>
          <h1><code>glob</code> module</h1>
          <p><code>glob(pattern)</code></p>
          <p><code>iglob(pattern)</code></p>
          <p><code>escape(pathname)</code></p>
          <p><code>translate(pathname)</code></p>
          <aside class="notes" data-markdown>
            - The `glob` module is much simpler
            - There's `glob`, `iglob`, and 2 other functions
          </aside>
        </section>

        <section>
          <h1><code>os.path</code> module</h1>
          <p><code>normpath(name)</code>, <code>abspath(path)</code></p>
          <p><code>basename(path)</code>, <code>dirname(path)</code></p>
          <p><code>isfile(path)</code>, <code>isdir(path)</code></p>
          <p><code>splitext(path)</code>, <code>getsize(path)</code></p>
          <p><code>relpath(path, parent)</code>, <code>join(parent, name)</code></p>
          <aside class="notes" data-markdown>
            - The `os.path` module is for manipulating file paths
            - Splitting paths apart, joining them together, and generally *asking questions* of path strings
          </aside>
        </section>

        <section>
          <h1 class="fragment" data-fragment-index=2>Python's Junk Drawers</h1>
          <h2 style="display: inline; margin-right: 2em;"><code>os</code></h2>
          <h2 class="fragment" data-fragment-index=1 style="display: inline;"><code>sys</code></h2>
          <h3 class="fragment" data-fragment-index=2 style="margin-top: 1em;">üîëüñáÔ∏è‚úèÔ∏èüß∑</h3>
          <aside class="notes" data-markdown>
            - The `os` module is a bit more complicated...
            - The Python standard library has 2 modules **(click)**...
            - That act as *junk drawers* **(click)**: the `os` module and the `sys` module
            - The `sys` module is the junk drawer for stuff related to the Python interpreter
            - The `os` module is the junk drawer for stuff related to the computer that your code is running on
            - ...
            - The `os` module has lots of file-related stuff *and* a bunch of other stuff
          </aside>
        </section>

        <section>
          <p class="fragment" data-fragment-index=1><code>os.getcwd()</code>, <code>os.chdir()</code></p>
          <p class="fragment" data-fragment-index=2><code>os.chmod()</code></p>
          <p class="fragment" data-fragment-index=3><code>os.symlink()</code>, <code>os.link()</code>, <code>os.readlink()</code></p>
          <p class="fragment" data-fragment-index=4><code>os.stat()</code>, <code>os.lstat()</code></p>
          <p class="fragment" data-fragment-index=4><code>os.scandir()</code>, <code>os.walk()</code></p>
          <p class="fragment" data-fragment-index=5><code>os.rename()</code>, <code>os.replace()</code>, <code>os.remove()</code></p>
          <p class="fragment" data-fragment-index=6><code>os.mkdir()</code>, <code>os.makedirs()</code></p>
          <aside class="notes" data-markdown>
            - There are **(click)** utilities for getting the current working directory and for changing it
            - For **(click)** changing the mode of a file
            - Stuff for **(click)** working with symbolic links and hard links
            - Utilities for **(click)** traversing the file system
            - Utilities for **(click)** renaming and replacing files
            - *And* utilities for **(click)** making directories
            - ...
            - These are most of the file-related utilities in Python's `os`
            - But this is *not* everything that's *in* the `os` module...
            - There's also all this...
          </aside>
        </section>

        <section>
          <p>
<code>os.abort()</code>,
<code>os.access()</code>,
<code>os.chown()</code>,
<code>os.chroot()</code>,
<code>os.close()</code>,
<code>os.closerange()</code>,
<code>os.confstr()</code>,
<code>os.copy_file_range()</code>,
<code>os.cpu_count()</code>,
<code>os.ctermid()</code>,
<code>os.device_encoding()</code>,
<code>os.dup()</code>,
<code>os.dup2()</code>,
<code>os.eventfd()</code>,
<code>os.eventfd_read()</code>,
<code>os.eventfd_write()</code>,
<code>os.execl()</code>,
<code>os.execle()</code>,
<code>os.execlp()</code>,
<code>os.execlpe()</code>,
<code>os.execv()</code>,
<code>os.execve()</code>,
<code>os.execvp()</code>,
<code>os.execvpe()</code>,
<code>os.fchdir()</code>,
<code>os.fchmod()</code>,
<code>os.fchown()</code>
          </p>
          <aside class="notes" data-markdown>
            - ...
            - And this...
          </aside>
        </section>

        <section>
          <p>
<code>os.fdatasync()</code>,
<code>os.fdopen()</code>,
<code>os.fork()</code>,
<code>os.forkpty()</code>,
<code>os.fpathconf()</code>,
<code>os.fsdecode()</code>,
<code>os.fsencode()</code>,
<code>os.fspath()</code>,
<code>os.fstat()</code>,
<code>os.fstatvfs()</code>,
<code>os.fsync()</code>,
<code>os.ftruncate()</code>,
<code>os.fwalk()</code>,
<code>os.get_blocking()</code>,
<code>os.get_exec_path()</code>,
<code>os.get_inheritable()</code>,
<code>os.get_terminal_size()</code>,
<code>os.getcwdb()</code>,
<code>os.getegid()</code>,
<code>os.getenv()</code>,
<code>os.getenvb()</code>,
<code>os.geteuid()</code>,
<code>os.getgid()</code>,
<code>os.getgrouplist()</code>,
<code>os.getgroups()</code>,
<code>os.getloadavg()</code>,
<code>os.getlogin()</code>,
<code>os.getpgid()</code>,
<code>os.getpgrp()</code>
          <aside class="notes" data-markdown>
            - ...
            - And this...
          </aside>
        </section>

        <section>
          <p>
<code>os.getpid()</code>,
<code>os.getppid()</code>,
<code>os.getpriority()</code>,
<code>os.getrandom()</code>,
<code>os.getresgid()</code>,
<code>os.getresuid()</code>,
<code>os.getsid()</code>,
<code>os.getuid()</code>,
<code>os.getxattr()</code>,
<code>os.grantpt()</code>,
<code>os.initgroups()</code>,
<code>os.isatty()</code>,
<code>os.kill()</code>,
<code>os.killpg()</code>,
<code>os.lchown()</code>,
<code>os.listdir()</code>,
<code>os.listxattr()</code>,
<code>os.lockf()</code>,
<code>os.login_tty()</code>,
<code>os.lseek()</code>,
<code>os.major()</code>,
<code>os.makedev()</code>,
<code>os.memfd_create()</code>,
<code>os.minor()</code>,
<code>os.mkfifo()</code>,
<code>os.mknod()</code>,
<code>os.nice()</code>,
<code>os.open()</code>,
<code>os.openpty()</code>,
<code>os.pathconf()</code>,
<code>os.pidfd_open()</code>
          <aside class="notes" data-markdown>
            - ...
            - and this...
          </aside>
        </section>

        <section>
          <p>
<code>os.pipe()</code>,
<code>os.pipe2()</code>,
<code>os.popen()</code>,
<code>os.posix_fadvise()</code>,
<code>os.posix_fallocate()</code>,
<code>os.posix_openpt()</code>,
<code>os.posix_spawn()</code>,
<code>os.posix_spawnp()</code>,
<code>os.pread()</code>,
<code>os.preadv()</code>,
<code>os.ptsname()</code>,
<code>os.putenv()</code>,
<code>os.pwrite()</code>,
<code>os.pwritev()</code>,
<code>os.read()</code>,
<code>os.readinto()</code>,
<code>os.readv()</code>,
<code>os.register_at_fork()</code>,
<code>os.remove()</code>,
<code>os.removedirs()</code>,
<code>os.removexattr()</code>,
<code>os.renames()</code>,
<code>os.rmdir()</code>
          <aside class="notes" data-markdown>
            - ...
            - *and*...
          </aside>
        </section>

        <section>
          <p>
<code>os.sched_get_priority_max()</code>,
<code>os.sched_get_priority_min()</code>,
<code>os.sched_getaffinity()</code>,
<code>os.sched_getparam()</code>,
<code>os.sched_getscheduler()</code>,
<code>os.sched_rr_get_interval()</code>,
<code>os.sched_setaffinity()</code>,
<code>os.sched_setparam()</code>,
<code>os.sched_setscheduler()</code>,
<code>os.sched_yield()</code>,
<code>os.sendfile()</code>,
<code>os.set_blocking()</code>,
<code>os.set_inheritable()</code>
          <aside class="notes" data-markdown>
            - This.
            - ...
            - Oh... and also...
          </aside>
        </section>

        <section>
          <p>
<code>os.setegid()</code>,
<code>os.seteuid()</code>,
<code>os.setgid()</code>,
<code>os.setgroups()</code>,
<code>os.setns()</code>,
<code>os.setpgid()</code>,
<code>os.setpgrp()</code>,
<code>os.setpriority()</code>,
<code>os.setregid()</code>,
<code>os.setresgid()</code>,
<code>os.setresuid()</code>,
<code>os.setreuid()</code>,
<code>os.setsid()</code>,
<code>os.setuid()</code>,
<code>os.setxattr()</code>,
<code>os.spawnl()</code>,
<code>os.spawnle()</code>,
<code>os.spawnlp()</code>,
<code>os.spawnlpe()</code>,
<code>os.spawnv()</code>,
<code>os.spawnve()</code>,
<code>os.spawnvp()</code>,
<code>os.spawnvpe()</code>,
<code>os.splice()</code>,
<code>os.statvfs()</code>,
<code>os.strerror()</code>,
<code>os.sync()</code>,
<code>os.sysconf()</code>,
<code>os.system()</code>,
<code>os.tcgetpgrp()</code>,
<code>os.tcsetpgrp()</code>
          <aside class="notes" data-markdown>
            - This.
            - ...
            - Plus this...
          </aside>
        </section>

        <section>
          <p>
<code>os.timerfd_create()</code>,
<code>os.timerfd_gettime()</code>,
<code>os.timerfd_gettime_ns()</code>,
<code>os.timerfd_settime()</code>,
<code>os.timerfd_settime_ns()</code>,
<code>os.times()</code>,
<code>os.truncate()</code>,
<code>os.ttyname()</code>,
<code>os.umask()</code>,
<code>os.uname()</code>,
<code>os.unlink()</code>,
<code>os.unlockpt()</code>,
<code>os.unsetenv()</code>,
<code>os.unshare()</code>,
<code>os.urandom()</code>,
<code>os.utime()</code>,
<code>os.wait()</code>,
<code>os.wait3()</code>,
<code>os.wait4()</code>,
<code>os.waitid()</code>,
<code>os.waitpid()</code>,
<code>os.waitstatus_to_exitcode()</code>,
<code>os.write()</code>,
<code>os.writev()</code>
          </p>
          <aside class="notes" data-markdown>
            - ...
            - *That* is everything in the `os` module
            - Well, that's all functions...
            - There are also dozens of constants... that I'm not going to show you
          </aside>
        </section>

        <section>
          <p><code>os.getcwd()</code>, <code>os.chdir()</code></p>
          <p><code>os.chmod()</code></p>
          <p><code>os.symlink()</code>, <code>os.link()</code>, <code>os.readlink()</code></p>
          <p><code>os.stat()</code>, <code>os.lstat()</code></p>
          <p><code>os.scandir()</code>, <code>os.walk()</code></p>
          <p><code>os.rename()</code>, <code>os.replace()</code>, <code>os.remove()</code></p>
          <p><code>os.mkdir()</code>, <code>os.makedirs()</code></p>
          <aside class="notes" data-markdown>
            - My point in dumping out the contents the `os` junk drawer
            - Is to point out how difficult it can be to *find* the dozen-ish file-related utilities that are *in* the `os` module
            - And these are just the file-related utilities that live in the `os` module...
            - This *doesn't* include everything in `os.path`, `shutil`, and `glob`...
          </aside>
        </section>

        <section>
          <p style="font-size: 90%;">
          <code style="white-space: nowrap;">shutil.copy(src, dst)</code>, <code style="white-space: nowrap;">shutil.copy2(src, dst)</code>,
          <code style="white-space: nowrap;">shutil.copytree(src, dst)</code>, <code style="white-space: nowrap;">shutil.move(src, dst)</code>,
          <code>shutil.rmtree(path)</code>,
          <code>os.getcwd()</code>, <code>os.chdir()</code>,
          <code>os.chmod()</code>,
          <code>os.symlink()</code>, <code>os.link()</code>, <code>os.readlink()</code>,
          <code>os.stat()</code>,
          <code>os.scandir()</code>, <code>os.walk()</code>,
          <code>os.rename()</code>, <code>os.replace()</code>, <code>os.remove()</code>
          <code>os.mkdir()</code>, <code>os.makedirs()</code>,
          <code>os.path.abspath(path)</code>,
          <code>os.path.basename(path)</code>, <code>os.path.dirname(path)</code>,
          <code>os.path.isfile(path)</code>, <code>os.path.isdir(path)</code>,
          <code>os.path.splitext(path)</code>, <code>os.path.getsize(path)</code>,
          <code style="white-space: nowrap;">os.path.relpath(path, parent)</code>, <code style="white-space: nowrap;">os.path.join(parent, name)</code>,
          <code>glob.glob(pattern)</code>
          <aside class="notes" data-markdown>
            - These are *most* of the useful path-related utilities included in Python's `os`, `os.path`, `shutil`, and `glob` modules...
            - I say *most* because I removed about 10 less frequently used functions that didn't fit on this slide
            - Back in 2015, in Python 2.7, our only option when working with file paths was to go hunting for these utilities when we needed them
          </aside>
        </section>

        <section>
          <h2>Problems with pathlib alternatives</h2>
          <ul style="list-style: none; font-size: 1.2em; line-height: 1.5;">
            <li style="color: #28a745;">‚òë Utilities are difficult to find</li>
            <li>‚òê Utilities are awkward to use</li>
            <li>‚òê String paths are error-prone</li>
            <li>‚òê Hard to distinguish paths from other strings</li>
          </ul>
          <aside class="notes" data-markdown>
            - So, I think we can agree that the various path-related utilities scattered throughout the Python standard library are...
            - *difficult* to find
            - ...
            - But do we even need all these utility functions?
          </aside>
        </section>

      </section>

      <!-- SECTION: Why even use os.path? -->
      <!-- 2 minutes -->
      <section>

        <section>
          <h2><strong><code>os.path</code></strong> versus <strong>string operations</strong></h2>
          <aside class="notes" data-markdown>
            - If we're representing file paths as strings... couldn't we just manipulate the strings with string operations?
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape style="font-size: 95%">
import os.path

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
TEMPLATES_DIR = os.path.join(BASE_DIR, "templates")
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape style="font-size: 95%">
import os.path

BASE_DIR = os.path.abspath(__file__).rsplit("/", maxsplit=2)[0]
TEMPLATES_DIR = BASE_DIR  + "/templates"
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape style="font-size: 95%">
import os
import os.path

BASE_DIR = os.path.abspath(__file__).rsplit(os.sep, maxsplit=2)[0]
TEMPLATES_DIR = BASE_DIR  + os.sep + "templates"
          </code></pre>
          <aside class="notes" data-markdown>
            - This code was taken from a Django project
            - It sets `BASE_DIR` to the directory above the current file's directory
            - And it sets `TEMPLATES_DIR` to the templates subdirectory within that base directory
            - But these file paths are just strings...
            - So instead of using `os.path.dirname` and `os.path.join`, **(click)** couldn't we just use the string `rsplit` method and string concatenation?
            - Well, this code *is* shorter, but it's probably buggy on Windows, which usually uses backslashes instead of forward slashes...
            - We *could* have relied on `os.sep` **(click)** to make this code work on all operating systems...
            - But I think *this code* is *less readable* than the `os.path` version.
            - Also, depending on where our path came from, ...
          </aside>
        </section>

        <section>
          <h3>Mixed slashes üò∞</h3>
          <pre class="python"><code data-trim data-noescape>
          C:\Documents\ever\seen/a path/like this.txt
          </code></pre>
          <aside class="notes" data-markdown>
            - ...we might accidentally end up with a mix of forward slashes and back slashes, which is technically valid on Windows but it also looks really weird
            - Which... is why
          </aside>
        </section>

        <section>
          <h1><code>os.path</code> module</h1>
          <p><code>normpath(name)</code>, <code>abspath(path)</code></p>
          <p><code>basename(path)</code>, <code>dirname(path)</code></p>
          <p><code>isfile(path)</code>, <code>isdir(path)</code></p>
          <p><code>splitext(path)</code>, <code>getsize(path)</code></p>
          <p><code>relpath(path, parent)</code>, <code>join(parent, name)</code></p>
          <aside class="notes" data-markdown>
            - the many `os.path` utilities are useful
            - But performing *string manipulations* on path strings can get us in trouble
            - If we forget to use these utilities, and instead perform *string manipulations* on our path strings, we *might* end up with buggy code
          </aside>
        </section>

        <section>
          <h2>Problems with pathlib alternatives</h2>
          <ul style="list-style: none; font-size: 1.2em; line-height: 1.5;">
            <li>‚òë Utilities are difficult to find</li>
            <li>‚òê Utilities are awkward to use</li>
            <li style="color: #28a745;">‚òë String paths are error-prone</li>
            <li>‚òê Hard to distinguish paths from other strings</li>
          </ul>
          <aside class="notes" data-markdown>
            - So using strings to represent paths can easily lead to bugs unless we're *very careful* to use the proper *path manipulation* tools
            - ...
            - But potential bugs aren't the only issue with representing paths as strings...
          </aside>
        </section>

      </section>

      <!-- SECTION: Stringly typed path code -->
      <!-- 2 minutes -->
      <section>
        <section>
          <h1>Stringly Typed Code</h1>
          <p class="fragment">passes strings around when a better type exists</p>
          <aside class="notes" data-markdown>
            - Stringly-typed code **(click)** is code that passes strings around when a *better* type exists
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
target = "2025-09-25"

if target[:4] == "2025":
    print("That's this year")
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
from datetime import datetime

user_input = "2025-09-25"
target = datetime.strptime(user_input, "%Y-%m-%d").date()

if target.year == 2025:
    print("That's this year")
          </code></pre>
          <aside class="notes" data-markdown>
            - This code is stringly-typed: it uses a string to represent a date
            - **(click)** This code uses the `datetime` module to represent a `date` instead
            - I prefer this second block of code. It's a bit easier to work with date objects than with strings *and* we automatically get a bit more certainty about whether the data we're working with might be invalid.
          </aside>
        </section>

        <section>
          <h3><span class="fragment fade-out" data-fragment-index=1>The age-old tradition of path strings</span></h3>
          <pre class="python"><code data-trim data-noescape style="font-size: 95%">
import os.path

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
TEMPLATES_DIR = os.path.join(BASE_DIR, "templates")
          </code></pre>
          <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape style="font-size: 95%">
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
TEMPLATES_DIR = BASE_DIR / "templates"
          </code></pre>
          <aside class="notes" data-markdown>
            - As we've discussed, old Python code always used strings to represent file paths
            - ... I would argue that *this* is stringly-typed code
            - There is a *better way* to write this code **(click)**
            - ... using the `Path` class from Python's `pathlib` module
            - We'll address the differences between these 2 coding styles in a moment...
            - But first, I'd like to acknowledge the fact that using `Path` objects instead of a string makes it easier to distinguish between filenames and *any other* string
          </aside>
        </section>

        <section>
          <h3>Type annotation confusion</h3>
          <pre class="python"><code data-trim data-noescape>
from typing import Optional

# Are these meant to represent filenames or file contents?
question: Optional[str] = None
answer: Optional[str] = None

def find_editorconfig_file() -> str:
    ...  # Does this return a file path or file contents?
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
from pathlib import Path
from typing import Optional

question: Optional[Path] = None
answer: Optional[Path] = None

def find_editorconfig_file() -> Path:
    ...  #
          </code></pre>

          <aside class="notes" data-markdown>
            - If your code uses type annotations **(click)**, a file path might look just like any other string
            - Which can make it harder to catch path-related bugs
            - And it can make it harder to reason about your code
          </aside>
        </section>

        <section>
          <h2>Problems with pathlib alternatives</h2>
          <ul style="list-style: none; font-size: 1.2em; line-height: 1.5;">
            <li>‚òë Utilities are difficult to find</li>
            <li>‚òê Utilities are awkward to use</li>
            <li>‚òë String paths are error-prone</li>
            <li style="color: #28a745;">‚òë Hard to distinguish paths from other strings</li>
          </ul>
          <aside class="notes" data-markdown>
            - We've seen:
              - that the alternatives to pathlib are difficult to find
              - that path strings are error-prone
              - and that path strings also make it difficult to distinguish between paths and non-path strings
            - I'd like to quickly address my last point by comparison to pathlib...
          </aside>
        </section>

      </section>

      <!-- SECTION: Awkward paths -->
      <!-- 3 minutes -->
      <section>

        <section>
          <h2><strong>String paths</strong> versus <strong><code>Path</code></strong> objects</h2>
          <aside class="notes" data-markdown>
            - Let's compare the readability of code that represents paths as strings to the same code that uses `pathlib.Path` objects
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape style="font-size: 95%">
import os.path
BASE_DIR = <span class="fragment bold-current" data-fragment-index=3>os.path.dirname</span>(<span class="fragment bold-current" data-fragment-index=2>os.path.dirname</span>(<span class="fragment bold-current" data-fragment-index=1>os.path.abspath</span>(__file__)))
TEMPLATES_DIR = os.path.join(BASE_DIR, "templates")
          </code></pre>
          <pre class="python fragment" data-fragment-index=4><code data-trim data-noescape style="font-size: 95%">
from pathlib import Path
BASE_DIR = Path(__file__).<span class="fragment bold-current" data-fragment-index=5>resolve()</span>.<span class="fragment bold-current" data-fragment-index=6>parent</span>.<span class="fragment bold-current" data-fragment-index=7>parent</span><span class="fragment" data-fragment-index=8></span>
TEMPLATES_DIR = BASE_DIR / "templates"
          </code></pre>
          <aside class="notes" data-markdown>
            - This code represents paths using strings
            - I find that I need to read this code inside out: we get the absolute path **(click)**, then the parent directory **(click)**, and then get its parent directory. **(click)**
            - Instead of this code which uses strings for paths, I prefer **(click)** this code
            - This code represents paths using `pathlib.Path` objects
            - I read *this* from left-to-right: we **(click)** resolve the path into an absolute path, get **(click)** the parent directory, and get **(click)** its parent directory.
            - When using strings as paths, **(click)** we need to use **nested function calls**
            - but when using `Path` objects we can use **chained method calls and attribute accesses**.
            - Personally, I think the pathlib version reads much more naturally
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
from os.path import isdir, join, isfile
from glob import iglob
# ...
if isdir(path):
    for path in <span class="fragment bold-current">iglob(join(path, "*.py"), recursive=True)</span>:
        if isfile(path):
            process_file(path)
else:
    process_file(path)
          </code></pre>
          <pre class="python"><code data-trim data-noescape>
from pathlib import Path
# ...
if path.is_dir():
    for path in <span class="fragment bold-current">path.rglob("*.py")</span>:
        if path.is_file():
            process_file(path)
else:
    results.append(process_file(path))<span class="fragment"></span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Here's another example comparing the `glob` module and `pathlib`
            - Instead of **(click)** joining a path and then passing it to `iglob`, with `pathlib` we can **(click)** just call the `rglob` method on that path
            - Shorter code **(click)** isn't *always* more readable, but when the shorter code has less noise it usually *is*
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
with open("config.txt", mode="rt") as file:
    content = file.read()
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
content = Path("config.txt").read_text()
          </code></pre>
          <aside class="notes" data-markdown>
            - I very often need to open a file, read the whole contents of the file into a string, and then close the file
            - With `pathlib`, there's a convenience method for that **(click)**
            - Instead of using the `open` function, we could just call the `read_text` method on a `Path` object
          </aside>
        </section>

        <section>
          <table style="font-size: 0.6em; width: 100%;">
            <tr>
              <th>Task</th>
              <th>The old way</th>
              <th>The pathlib way</th>
            </tr>
            <tr class="fragment" data-fragment-index=1>
              <td style="border: 0; font-size: 110%;">Make dir</td>
              <td style="border: 0;"><code>os.mkdir(path)</code></td>
              <td style="border: 0; vertical-align: middle;" rowspan="2"><code class="fragment" data-fragment-index=3>path.mkdir(<span class="fragment bold-current" data-fragment-index=4>parents=True</span>)</code></td>
            </tr>
            <tr class="fragment" data-fragment-index=2>
              <td style="border: 0; font-size: 110%;">with parents</td>
              <td style="border: 0;"><code>os.makedirs(path)</code></td>
            </tr>
            <tr>
              <td colspan=3></td>
            </tr>
            <tr class="fragment" data-fragment-index=5>
              <td style="border: 0; font-size: 110%;" rowspan=2>Copy file</td>
              <td style="border: 0;">
                <code class="fragment" data-fragment-index=8>shutil.copyfile(src, dst)</code><br>
                <code class="fragment" data-fragment-index=9>shutil.copy(src, dst)</code><br>
                <code class="fragment" data-fragment-index=10>shutil.copy2(src, dst)</code><br>
                <code class="fragment" data-fragment-index=11>shutil.copytree(src, dst)</code>
              </td>
              <td style="border: 0; vertical-align: middle;">
                <span class="fragment" data-fragment-index=6><code>path.copy(dst)</code> <small>(3.14+)</small></span><br>
                <span class="fragment" data-fragment-index=7><code>path.copy_into(dst)</code> <small>(3.14+)</small></span>
              </td>
            </tr>
          </table>
          <aside class="notes" data-markdown>
            - The methods on the `pathlib.Path` class are a bit more deliberately designed than many of the other path-related functions included in Python
            - If you wanted to make a directory without `pathlib`, you would use either **(click)** `os.mkdir` *or* **(click)** `os.makedirs`, depending on whether you wanted to make parent directories
            - With `Path` objects, **(click)** the `mkdir` method *includes* the ability to make missing parent directories, thanks to **(click)** the optional `parents` keyword argument
            - ...
            - Copying files **(click)** is another good example of where `pathlib` shines...
            - In Python 3.14, `pathlib`'s `Path` class will have a `copy` method **(click)** and a `copy_into` method **(click)**
            - Before these 2 methods existed, we needed to reach for either `copyfile` **(click)**, `copy` **(click)**, `copy2` **(click)**, or `copytree` **(click)** from `shutil`
            - All of these have *slightly* different uses and *I* always needed to read the documentation to figure which one to use
          </aside>
        </section>

        <section>
          <h2>Problems with pathlib alternatives</h2>
          <ul style="list-style: none; font-size: 1.2em; line-height: 1.5;">
            <li>‚òë Utilities are difficult to find</li>
            <li style="color: #28a745;">‚òë  Utilities are awkward to use</li>
            <li>‚òë String paths are error-prone</li>
            <li>‚òë Hard to distinguish paths from other strings</li>
          </ul>
          <aside class="notes" data-markdown>
            - So code that uses pathlib is often more readable than the alternative
          </aside>
        </section>

      </section>

      <!-- SECTION: Python supports a better way -->
      <!-- 4 minutes -->
      <section>
        <section>
          <h2>How does <code>pathlib</code> work?</h2>
          <aside class="notes" data-markdown>
            - But how does `pathlib` actually work?
            - Well, the `pathlib` module contains pretty much one thing...
          </aside>
        </section>

        <section>
          <h3>It's all about <code>Path</code> objects</h3>
          <pre class="python"><code data-trim data-noescape>
>>> from pathlib import Path
>>> <span class="fragment">path = Path(".editorconfig")
>>> </span><span class="fragment">path
PosixPath('.editorconfig')
</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - ...a class called `Path`
            - So understanding `pathlib` means understanding `Path` objects and the `Path` class
            - The `Path` class **(click)** accepts a string which represents a file path and returns a new `Path` object
            - The `Path` object we get will either be **(click)** a `PosixPath` or a `WindowsPath`, depending on the operating system that the code is running on
            - Both types support all the same features, but they normalize paths differently
            - We don't need to worry about any of that because the `Path` object we get should work just the way we'd expect it to on whatever operating system the code is running on
          </aside>
        </section>

        <section>
          <p style="font-size: 90%; font-family: monospace;">
          <span class="fragment bold-current" data-fragment-index=1>
          <code>p.chmod()</code>,
          <code>p.copy()</code>,
          <code>p.copy_into()</code>,
          <code>p.exists()</code>,
          <code>p.expanduser()</code>,
          <code>p.glob()</code>,
          <code>p.is_dir()</code>,
          <code>p.is_file()</code>,
          <code>p.iterdir()</code>,
          <code>p.mkdir()</code>,
          <code>p.move()</code>,
          <code>p.move_into()</code>,
          <code>p.read_text()</code>,
          <code>p.rename()</code>,
          <code>p.replace()</code>,
          <code>p.resolve()</code>,
          <code>p.rglob()</code>,
          <code>p.rmdir()</code>,
          <code>p.stat()</code>,
          <code>p.unlink()</code>,
          <code>p.walk()</code>,
          <code>p.write_text()</code>,
          <code>p.joinpath()</code>,
          <code>p.relative_to()</code>,
          <code>p.with_name()</code>,
          <code>p.with_stem()</code>,
          <code>p.with_suffix()</code>,
          </span>
          <span class="fragment bold-current" data-fragment-index=3>
          <code>Path.cwd()</code>,
          <code>Path.home()</code>,
          </span>
          <span class="fragment bold-current" data-fragment-index=2>
          <code>p.name</code>,
          <code>p.parent</code>,
          <code>p.parents</code>,
          <code>p.parts</code>,
          <code>p.stem</code>,
          <code>p.suffix</code>
          </span>
          </p>
          <aside class="notes" data-markdown>
            - This is pretty much all of the useful features that the `Path` class supports
            - Most of these are **(click)** methods that you can call on individual `Path` objects
            - Some of these are **(click)** attributes of the `Path` objects
            - And 2 of these are **(click)** class methods: one returns the current working directory and the other returns the user's home directory
            - Technically these are only about *half* of the 70-ish methods and attributes on `Path` objects...
          </aside>
        </section>

        <section>
          <p style="font-size: 90%; font-family: monospace;">
          <code>p.absolute()</code>,
          <code>p.as_uri()</code>,
          <code>p.is_fifo()</code>,
          <code>p.group()</code>,
          <code>p.hardlink_to()</code>,
          <code>p.is_block_device()</code>,
          <code>p.is_char_device()</code>,
          <code>p.is_junction()</code>,
          <code>p.is_mount()</code>,
          <code>p.is_socket()</code>,
          <code>p.is_symlink()</code>,
          <code>p.lchmod()</code>,
          <code>p.lstat()</code>,
          <code>p.open()</code>,
          <code>p.owner()</code>,
          <code>p.readlink()</code>,
          <code>p.read_bytes()</code>,
          <code>p.samefile()</code>,
          <code>p.symlink_to()</code>,
          <code>p.touch()</code>,
          <code>p.write_bytes()</code>,
          <code>Path.from_uri()</code>,
          <code>p.as_posix()</code>,
          <code>p.is_absolute()</code>,
          <code>p.is_relative_to()</code>,
          <code>p.is_reserved()</code>,
          <code>p.full_match()</code>,
          <code>p.match()</code>,
          <code>p.with_segments()</code>,
          <code>p.anchor</code>,
          <code>p.drive</code>,
          <code>p.root</code>,
          <code>p.suffixes</code>
          </p>
          <aside class="notes" data-markdown>
            - These are the rest of the methods and attributes
            - ... but I don't find myself using these ones very often
            - So... `Path` objects have lots of useful features built-in...
          </aside>
        </section>

        <section>
          <pre class="python fragment"><code data-trim data-noescape>
from pathlib import Path

path = Path("example.txt")
with open(<span class="fragment bold">str(path)</span>) as f:
    content = f.read()
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
from pathlib import Path

path = Path("example.txt")
with open(<strong>path</strong>) as f:
    content = f.read()</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - But what happens when you actually want to *use* a `Path` object as a file path?
            - Back when `pathlib` was first added to Python, **(click)** in order to actually *use* a `Path` object, you might have needed **(click)** to convert the `Path` to a string...
            - Today, that's completely unnecessary... **(click)**
            - Because Python's built-in `open` function accepts `Path` objects
            - The `open` function *used to* only accept strings, but since Python 3.6 `open` works with strings *and* with `pathlib.Path` objects
            - In fact... pretty much *every* utility in Python that accepts a file path as a string will *also* accept a `Path` object...
          </aside>
        </section>

        <section>
          <h3><code>pathlib</code> works everywhere you need it</h3>
          <p><code>os.chdir()</code></p>
          <p><code>shutil.chown()</code></p>
          <p><code>sqlite3.connect()</code></p>
          <p><code>logging.FileHandler()</code></p>
          <p><code>zipfile.ZipFile()</code></p>
          <p><code>subprocess.run()</code></p>
          <aside class="notes" data-markdown>
            - Whether you need to:
              - change directories
              - change the ownership of a file
              - connect to a sqlite database
              - log to a file
              - create a ZIP file
              - or run a subprocess
            - ...you can use `pathlib.Path` objects instead of using path strings...
            - You don't need to convert `Path` objects back to strings
            - Every standard library function that *should* accept `Path` objects, does
            - In fact even standard library utilities that are specifically designed for a path strings will also work with `Path` objects...
          </aside>
        </section>

        <section>
          <h3>It even works legacy utilities</h3>
          <p><code>os.path.abspath()</code></p>
          <p><code>os.path.isfile()</code></p>
          <p><code>os.path.join()</code></p>
          <p><code>os.remove()</code></p>
          <p><code>os.mkdir()</code></p>
          <p><code>shutil.copy()</code></p>
          <p><code>shutil.move()</code></p>
          <aside class="notes" data-markdown>
            - If you're still using `os.path` functions, that's okay...
            - All of these functions accept `pathlib.Path` objects
          </aside>
        </section>

        <section>
          <p style="font-size: 90%;">
          <code style="white-space: nowrap;">shutil.copy(src, dst)</code>, <code style="white-space: nowrap;">shutil.copy2(src, dst)</code>,
          <code style="white-space: nowrap;">shutil.copytree(src, dst)</code>, <code style="white-space: nowrap;">shutil.move(src, dst)</code>,
          <code>shutil.rmtree(path)</code>,
          <code>os.chmod()</code>,
          <code>os.symlink()</code>, <code>os.link()</code>, <code>os.readlink()</code>,
          <code>os.stat()</code>,
          <code>os.scandir()</code>, <code>os.walk()</code>,
          <code>os.rename()</code>, <code>os.replace()</code>, <code>os.remove()</code>
          <code>os.mkdir()</code>, <code>os.makedirs()</code>,
          <code>os.path.abspath(path)</code>,
          <code>os.path.basename(path)</code>, <code>os.path.dirname(path)</code>,
          <code>os.path.isfile(path)</code>, <code>os.path.isdir(path)</code>,
          <code>os.path.splitext(path)</code>, <code>os.path.getsize(path)</code>,
          <code style="white-space: nowrap;">os.path.relpath(path, parent)</code>, <code style="white-space: nowrap;">os.path.join(parent, name)</code>
          </p>
          <aside class="notes" data-markdown>
            - Every path-related tool we saw earlier that *accepts* a file path string will also accept a `pathlib.Path` object...
            - So you can *usually* pass `Path` objects to legacy code that was written *without* `pathlib` in mind and it will *often* just work
          </aside>
        </section>

        <section>
          <h3>Third-party libraries support <code>Path</code> objects</h3>
          <div>
            <p class="fragment"><code>django</code> (in <code>settings</code> for example)</p>
            <p class="fragment"><code>pandas.read_csv(path)</code></p>
            <p class="fragment"><code>PIL.Image.open(path)</code></p>
            <p class="fragment"><code>pytest.main([path])</code></p>
            <p class="fragment"><code>click.File()(path)</code></p>
          </div>
          <aside class="notes" data-markdown>
            - Even most third-party libraries that handle file paths will usually *also* accept `pathlib.Path` objects...
            - Django **(click)**
            - pandas **(click)**
            - pillow **(click)**
            - pytest **(click)**
            - and click **(click)**
            - ... all support `Path` objects
            - Most modern Python libraries work just fine with `pathlib`
          </aside>
        </section>
      </section>

      <!-- SECTION: Okay, but how? -->
      <!-- 3 minutes -->
      <section>
        <section>
          <h2>Using <code>pathlib</code></h2>
          <aside class="notes" data-markdown>
            - So `pathlib` is great...
            - But in practice, how should you start using `pathlib`?
          </aside>
        </section>

        <section>
          <h3>Creating <code>Path</code> objects</h3>
          <pre class="python"><code data-trim data-noescape>
>>> from pathlib import Path
>>> <span class="fragment">notes_path = Path("Documents/notes.txt")
>>> </span><span class="fragment">notes_path
WindowsPath('documents/notes.txt')
>>> </span><span class="fragment">notes_path2 = Path(r"documents\notes.txt")
>>> </span><span class="fragment">notes_path2
WindowsPath('documents/notes.txt')
>>> </span><span class="fragment">notes_path2 == notes_path
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Pretty much anytime you encounter a string that represents a file path **(click)**, you'll pass that string to the `Path` class to get `Path` object **(click)**
            - When you're writing cross-platform compatible code, you'll want to use forward slashes in the string literals you pass to `pathlib.Path`
            - ... but don't worry about backslashes on Windows! **(click)**
            - If you end up with a backslash-separated path on a Windows machine, pathlib will normalize it automatically! **(click)**
            - On Windows, this path with backslash separators will be interpreted **(click)** the same way as *this* path with forward slash separators
            - ...
            - Once you have a `Path` object...
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
<span class="fragment">>>> from pathlib import Path
>>> home = Path.home()
>>> </span><span class="fragment">path1 = home.joinpath(".config.toml")
>>> </span><span class="fragment">path2 = home / ".config.toml"
>>> </span><span class="fragment">path3 = Path(home, ".config.toml")
>>> </span><span class="fragment">path3
PosixPath('/home/trey/.config.toml')
>>> </span><span class="fragment">path1 == path2 == path3
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - ...there are lots of things you can do with it
            - If your `Path` object represents a directory **(click)**, you may end up joining your path with a filename
            - You can do that with...
            - the `joinpath` method **(click)**
            - or by using the `/` operator **(click)**
            - Which looked a bit odd to me at first, but now that I'm used to it, I find this pretty readable
            - Also, the `Path` class **(click)** can accept multiple arguments to join together... and those arguments can be either strings or other `Path` objects
            - So this **(click)** joins our home directory path with this config filename
            - All 3 of these approaches **(click)** return equivalent `Path` objects
            - And none of these is necessarily better than the others
            - Although, you'll usually only see that third approach used if we're not sure whether `home` is a `Path` object or a string
          </aside>
        </section>

        <section>
          <h3>Consolidated functionality</h3>
          <table style="font-size: 0.75em; width: 100%;">
            <tr>
              <th>pathlib</th>
              <th>Traditional approach</th>
              <th>Returns</th>
            </tr>
            <tr>
              <td><code>Path(name)</code></td>
              <td><code>os.path.normpath(name)</code></td>
              <td><code>Path</code></td>
            </tr>
            <tr>
              <td><code>path.resolve()</code></td>
              <td><code>os.path.abspath(path)</code></td>
              <td><code>Path</code></td>
            </tr>
            <tr class="fragment bold-current">
              <td><code>path.name</code></td>
              <td><code>os.path.basename(path)</code></td>
              <td><code>str</code></td>
            </tr>
            <tr class="fragment bold-current">
              <td><code>path.parent</code></td>
              <td><code>os.path.dirname(path)</code></td>
              <td><code>Path</code></td>
            </tr>
            <tr class="fragment bold-current">
              <td><code>path.suffix</code></td>
              <td><code>os.path.splitext(path)[1]</code></td>
              <td><code>str</code></td>
            </tr>
            <tr>
              <td><code>path.stem</code></td>
              <td><code>os.path.splitext(path)[0]</code></td>
              <td><code>str</code></td>
            </tr>
            <tr>
              <td><code>path.is_file()</code></td>
              <td><code>os.path.isfile(path)</code></td>
              <td><code>bool</code></td>
            </tr>
            <tr>
              <td><code>parent / name</code></td>
              <td><code>os.path.join(parent, name)</code></td>
              <td><code>Path</code></td>
            </tr>
          </table>
          <aside class="notes" data-markdown>
            - I always found the functions in `os.path` to be unfortunately named...
            - Lots of shortened words all squashed together...
            - With pathlib, all the same functionality exists as either *methods* or *attributes* on `Path` objects
            - And they're all pretty well-named
            - Personally, I prefer **(click)** the `name` attribute over the `basename` function
            - **(click)** the `parent` attribute over the `dirname` function
            - and **(click)** the `suffix` attribute over calling `splitext` function and accessing index 1
            - If you're looking for a pathlib cheat sheet...
          </aside>
        </section>

        <section>
          <h1>Cheat Sheets</h1>
          <h2><code><a href="https://pym.dev/pathlib-module/">pym.dev/pathlib-module</a></code></h2>
          <p><code><a href="https://pyref.dev/pathlib#corresponding-tools">pyref.dev/pathlib#corresponding-tools</a></code></p>
          <aside class="notes" data-markdown>
            - ...you can find a couple of cheat sheet tables in that first URL, which is an article that I wrote on pathlib
            - And there's also a table at the bottom of the `pathlib` documentation... which is where that second URL goes
          </aside>
        </section>

      </section>

      <!-- SECTION: This isn't just about pathlib -->
      <!-- 4 minutes -->
      <section>
        <section>
          <h2>This isn't just about <code>pathlib</code></h2>
          <aside class="notes" data-markdown>
            - This talk *is* about pathlib... but it isn't *just* about pathlib
            - Code that uses `pathlib` can also work with code that *inherits* from `pathlib.Path`...
            - *And* it's also possible to practice *duck tying* when it comes to path objects
          </aside>
        </section>

        <section>
          <h3>Extending <code>pathlib.Path</code></h3>
          <pre class="python"><code data-trim data-noescape style="font-size: 85%">
import os
import pathlib

class BetterPath(pathlib.Path):
    def chdir(self):
        os.chdir(self)
          </code></pre>
          <p class="fragment">Python 3.12+ officially supports pathlib inheritance</p>
          <pre class="python fragment"><code data-trim data-noescape style="font-size: 85%">
>>> BetterPath.home().chdir()
          </code></pre>
          <aside class="notes" data-markdown>
            - Since Python 3.12, **(click)** you can extend the functionality of `pathlib` through inheritance
            - So if you'd like to make your own `Path` objects that include a method to change directories, you can!
            - You'll just inherit from `pathlib.Path` and then **(click)** use your own custom `BetterPath` class the same way you'd use the `pathlib.Path` class
          </aside>
        </section>

        <section>
          <pre class="python fragment" data-fragment-index=3><code data-trim data-noescape style="font-size: 70%">
>>> git_path = GitPath("src/main.py", repo_root=".")
>>> <span class="fragment" data-fragment-index=4>git_path.parent  # repo_root is preserved when creating new paths
GitPath('/home/user/project/src', <span class="fragment bold" data-fragment-index=4>repo_root='/home/user/project')</span></span>
          </code></pre>
          <pre class="python"><code data-trim data-noescape style="font-size: 70%">
class GitPath(pathlib.Path):
    def __init__(self, *segments, repo_root):
        super().__init__(*segments)
        <span class="fragment bold" data-fragment-index=2>self.repo_root = pathlib.Path(repo_root).resolve()</span>

    def <span class="fragment bold" data-fragment-index=1>with_segments</span>(self, *args):
        """Ensure any derived paths remember the repo root."""
        return type(self)(*args, repo_root=self.repo_root)

    def relative_to_repo(self):
        return self.relative_to(self.repo_root or self.root)

    def __repr__(self):
        return f"{type(self).__name__}({str(self)!r}, repo_root={self.repo_root!r})"
          </code></pre>
          <aside class="notes" data-markdown>
            - If you need to attach *metadata* to a custom `Path` object, you can override the `with_segments` method **(click)** to ensure that the metadata is preserved for any *new* `Path` that's *derived* from an *existing* `Path`
            - In our case, we have a `Path` subclass with an additional `repo_root` attribute **(click)**
            - If we get our path's parent directory **(click)**, our `repo_root` attribute **(click)** will be maintained on the new `GitPath` object that's generated
            - The same thing would happen if we joined our path with another path: all methods that generate *new* paths call the `with_segments` method
            - This pattern makes it pretty easy to make specialized `Path` subclasses
            - ...
            - So you can make a sort of `pathlib` alternative by inheriting from `pathlib.Path`
            - But you can also make `pathlib` alternatives through *duck typing* **(click)**
          </aside>
        </section>

        <section>
          <h1>ü¶Ü</h1>
          <ul>
            <li class="fragment">Lists and tuples are sequences</li>
            <li class="fragment">Dictionaries are mappings</li>
            <li class="fragment">Files are file-like objects</li>
            <li class="fragment"><code>pathlib.Path</code> objects are Path-like objects</li>
          </ul>
          <aside class="notes" data-markdown>
            - An object **(click)** that acts like a list or a tuple is a sequence
            - An object **(click)** that acts like a dictionary is a mapping
            - An object **(click)** that acts like a file is a file-like object
            - And an object **(click)** that can be used where `Path` objects can be used is a Path-like object
            - If it looks like a duck and quacks like a duck, then it's a duck
            - And... if it's accepted by utilities that accept `Path` objects, *then* it's a Path-like object
          </aside>
        </section>

        <section>
          <h1>PEP 519</h1>
          <ul>
            <li class="fragment">Defines the <code>os.PathLike</code> protocol</li>
            <li class="fragment">Built-in functions like <code>open()</code> accept path-like objects</li>
            <li class="fragment">Any object with a <code>__fspath__()</code> method works</li>
            <li class="fragment">Third-party libraries use <code>os.fspath()</code> paths to strings</li>
            <li class="fragment">Enables third-party path-like objects</li>
          </ul>
          <aside class="notes" data-markdown>
            - PEP 519 defines **(click)** the Path-like protocol
            - All Path-like objects are accepted by **(click)** `open`, and all other built-in path tools
            - The only thing that's needed **(click)** for a Path-like object is a `\_\_fspath__` method
            - That *one* method will allow an object be accepted by all of Python's many path-accepting functions
            - And **(click)** any third-party utility that wants to convert a Path-like object into a string can use the `os.fspath` function to do so
            - This PEP allows **(click)** for a whole ecosystem of Path-like objects beyond just `pathlib`
            - For example...
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
import os

class MyPath:
    def __init__(self, path):
        self.path = os.fspath(path)
    
    def __fspath__(self):
        return self.path

my_path = MyPath("example.txt")

with <span class="fragment bold">open(my_path)</span> as file:
    content = file.read()
          </code></pre>
          <aside class="notes" data-markdown>
            - ...here's a class called `MyPath` which *does not* inherit from `pathlib.Path`
            - And yet, instances of this class *work* **(click)** with the built-in `open` function
            - The ability to make an object that *acts* like a path allows for third-party libraries that work everywhere that `pathlib` does
          </aside>
        </section>

      </section>

      <!-- SECTION: pathlib anti-patterns -->
      <!-- 1 minute -->
      <section>
        <section>
          <h2>pathlib anti-patterns</h2>
          <aside class="notes" data-markdown>
            - Before we conclude, I'd like to make sure to discuss a couple common mistakes that new `pathlib` users often make
          </aside>
        </section>

        <section>
          <h3>Using the <code>open</code> method</h3>
          <pre class="python"><code data-trim data-noescape>
path = Path("example.txt")
with <span class="fragment bold">path.open()</span> as file:
    contents = file.read()
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
path = Path("example.txt")
with <strong>open(path)</strong> as file:
    contents = file.read()</span>
          </code></pre>
          <p class="fragment">The <code>open</code> method is a relic from an earlier time</p>
          <aside class="notes" data-markdown>
            - The `Path` class has an `open` method
            - Back in Python 3.5, **(click)** the `open` method was the official way to get an open file out of a `Path` object
            - The Path-like interface was added in Python 3.6 thanks to PEP 519, **(click)** so now `Path` objects work with the built-in `open` function
            - There is no reason to use the `open` method anymore **(click)**
            - The `open` method only exists because there were 2 versions of Python that included `pathlib`, before the `open` function worked with `pathlib`
            - So I recommend *against* the `open` method
            - I consider the `Path` `open` method to be a *relic* from an earlier version of Python
          </aside>
        </section>

        <section>
          <h3>Unnecessary string conversion</h3>
          <pre class="python fragment"><code data-trim data-noescape>
>>> print(f"Reading: {path}")
Reading: example.txt
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
path = Path("example.txt")
with open(<strong>str(path)</strong>) as f:
    content = f.read()
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
path = Path("example.txt")
with open(<strong>path</strong>) as f:
    content = f.read()</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If I need display a path to an end user or log it to a file...
            - I'll often **(click)** implicitly convert it to a string by using it in `print` call or in an f-string
            - And that's useful
            - But don't convert `Path` objects to strings **(click)** when you don't need to **(click)**
            - If you think you need to convert a `Path` to a string, you probably don't
          </aside>
        </section>

        <section>
          <h3>Better Path constructor usage</h3>
          <pre class="python"><code data-trim data-noescape>
<span class="fragment">config = Path(directory)<span class="fragment">.joinpath(".editorconfig")</span></span>
<span class="fragment">config = Path(directory) / ".editorconfig"</span>
<span class="fragment">config = Path(directory, ".editorconfig")</span>
          </code></pre>
          <p class="fragment">Works whether <code>directory</code> is a string or Path object</p>
          <aside class="notes" data-markdown>
            - Also, don't forget that the `Path` constructor can accept multiple arguments
            - So if you have a directory string and a file string and you'd like to join them together, you don't need to **(click)** make a `Path` object and then **(click)** use `joinpath` or **(click)** the `/` operator...
            - You can just **(click)** pass both of your strings to the `Path` class
            - This **(click)** even works if you're not sure whether one of these is already a `Path` object...
          </aside>
        </section>

      </section>

      <!-- SECTION: Outro -->
      <!-- 2 minutes -->
      <section>
        <section>
          <h2>Use <code>pathlib</code>. You won't regret it.</h2>
          <ul>
            <li class="fragment">Cross-platform compatibility built-in</li>
            <li class="fragment">High-level APIs for common operations</li>
            <li class="fragment">Easier type-checking</li>
            <li class="fragment">More readable code</li>
          </ul>
          <aside class="notes" data-markdown>
            - So with pathlib...
            - It's easy to write code that **(click)** works on all operating systems
            - Many *common* path operations **(click)** are even simpler than they were before
            - And you get to **(click)** avoid awkward stringly-typed code
            - `pathlib` can help make your code **(click)** more readable and more maintainable
            - But... there's a very common concern I often hear about pathlib, that I feel is unwarranted...
          </aside>
        </section>

        <section>
          <h3>"But <code>pathlib</code> is slow"</h3>
          <p class="fragment">Yes, it can be slower for some operations</p>
          <p class="fragment">400,000 files searched</p>
          <p class="fragment">0.91 seconds with <code>os.walk()</code></p>
          <p class="fragment">0.85 seconds with <code>pathlib.Path().walk()</code></p>
          <p class="fragment">2.22 seconds when converting back to <code>pathlib.Path()</code></p>
          <p class="fragment"><strong>Don't optimize parts of your code that aren't bottlenecks</strong></p>
          <aside class="notes" data-markdown>
            - pathlib is slow
            - It *is* true that `pathlib` can be slower for *some* operations... **(click)**
            - But readability is sometimes worth a small performance penalty
            - I searched 400,000 files **(click)** with `os.walk` **(click)** and with the `pathlib` `walk` method **(click)**
            - And `pathlib` wasn't any slower...
            - Except, the `walk` method returns strings, which is a bit of a cheat...
            - When I converted all 4 hundred thousand paths back into `Path` objects in order to ask questions of them... **(click)**
            - My code *did* slow down
            - Although, unless I'm actually planning to process many thousands of files, this kind of slow down is *probably* not significant
            - Most path operations **aren't in tight loops**
            - **(click)** Readability is usually more important than micro-optimizations
            - Use the right tool for the right job.
            - Optimize only when it really matters.
          </aside>
        </section>

        <section>
          <h1>pathlib</h1>
          <p style="font-size: 1.5em;"><q>just another way to represent paths</q></p>
          <p style="font-size: 1.5em;" class="fragment"><q>the ideal way to represent file paths</q></p>
          <aside class="notes" data-markdown>
            - pathlib isn't just a different API **(click)**
            - pathlib is about acknowledging that file paths are important enough to warrant their own data type
            - ... a data type that's designed to make file path operations *easy*
            - It's about representing file paths *properly*
          </aside>
        </section>
      </section>

      <section>

        <!-- Thank you slide -->
        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h2 style="margin-top: 1.5em;">Thanks!</h2>
          <h3><a href="https://pym.dev/pathlib-module/">pym.dev/pathlib-module</a></h3>
          <!--<h3><a href="http://trey.io/pybeach2025">trey.io/pybeach2025</a></h3>-->
          <div style="margin-top: 2.5em;">
            <p style="float: left; margin-right: 2em;">
              <strong>Trey Hunner</strong><br>
              <small>Python Team Trainer</small>
            </p>
            <p style="float: left;">
            <a href="http://truthful.technology"><img src="horizontal-training-logo.svg" class="no-style logo"></a>
            <a href="http://pythonmorsels.com"><img src="horizontal-morsels-logo.svg" class="no-style logo"></a>
            </p>
          </div>
          <aside class="notes" data-markdown>
            - Thank you
          </aside>
        </section>

        <section>
          <h3>Gradual adoption</h3>
          <pre class="python"><code data-trim data-noescape>
# Start by converting at function boundaries
def process_config(config_path):
    path = Path(config_path)  # Works with strings OR Path objects
    return path.read_text()

# Legacy code still works
process_config("/path/to/config.txt")  # string path
process_config(Path("config.txt"))      # Path object

# Mix and match as you migrate
import os
for filename in os.listdir(directory):
    file_path = Path(directory) / filename  # pathlib joining
    if file_path.suffix == '.py':           # pathlib properties
        with open(file_path) as f:          # builtin functions accept Path
            content = f.read()
          </code></pre>
          <p class="fragment">The Path class accepts strings <em>and</em> other Path objects</p>
          <aside class="notes" data-markdown>
            - Something that's pretty great about `pathlib` is that you *can* gradually adopt `pathlib`
            - Path objects *should* work everywhere string paths work
            - And you can use the built-in `Path` class to make sure that the path you're working with is a `Path` object and not a string
            - Just as you can pass any iterable to the built-in `list` function to turn it into a `list`, including the `list` type, you can also pass either strings *or* `Path` objects to the `Path` class to make sure you're working with a `Path` object
          </aside>
        </section>

        <section>
          <h3>Using <code>pathlib.Path</code> with <code>argparse</code></h3>
          <pre class="python"><code data-trim data-noescape style="font-size: 90%">
# For immediate file opening:
parser.add_argument("input", type=argparse.FileType("r"))
# args.input is already an open file object

<span class="fragment"># For flexible path handling:
parser.add_argument("path", type=Path)
# args.path is a Path object

if args.path.is_dir():
    ...  # Directory given
elif args.path.is_file():
    ...  # Existing file given
else:
    ...  # Path doesn't represent a file or a directory!</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - (Two different approaches for different use cases)
            - FileType for immediate opening
            - Path type for flexible path handling
          </aside>
        </section>

        <section>
          <h3>More extension examples</h3>
          <pre class="python"><code data-trim data-noescape style="font-size: 75%">
# Add common_prefix functionality
class BetterPath(pathlib.Path):
    def common_prefix(self, other):
        return self.with_segments(os.path.commonprefix((self, other)))

<span class="fragment"># Enhanced rmdir with recursive option
class BetterPath(pathlib.Path):
    def rmdir(self, *, recursive=False, ignore_errors=False):
        if recursive:
            shutil.rmtree(self, ignore_errors=ignore_errors)
        else:
            try:
                super().rmdir()
            except Exception:
                if not ignore_errors:
                    raise</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If you wanted to add a `common_prefix` method because you miss that function from `os.path`, you can make your own `Path` class that has it!
            - You can also enhance the functionality of *existing* methods
            - For example, if you wanted to allow the `rmdir` method to delete non-empty directories, you could override the `rmdir` method
            - Note the `with_segments` method call in that `common_prefix` method...
            - That's the way for subclasses of `Path` to return new `Path` objects of the *same* type
            - But that method can *also* be helpful to override...
          </aside>
        </section>

        <section>
          <h3>Real third-party example: plumbum</h3>
          <pre class="python"><code data-trim data-noescape>
from plumbum import local

# This is a plumbum Path, not a pathlib Path
my_file = local.path("example.txt")

# But it works with open() because it has __fspath__
with open(my_file) as f:
    content = f.read()

# It also works with os.path functions
import os.path
print(os.path.exists(my_file))  # Works!
          </code></pre>
          <aside class="notes" data-markdown>
            - For example, the plumbum library has a Path class that works differently from pathlib's `Path` class, but it has a `__fspath__` method...
            - Which means, it also works with the built-in `open` function!
            - Thanks to this PEP 519, there are `pathlib` alternatives that work just as well as `pathlib` does
          </aside>
        </section>

      </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>


    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/title-footer/title-footer.js', async: true, callback: function() {
            title_footer.initialize("trey.io/pybeach2025", "rgba(0,255,0,0.0)");
          } }
        ]
      });
      if (window.self !== window.top) {
        document.body.className += " notes";
      }
    </script>
  </body>
</html>
