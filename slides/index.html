<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>pathlib: why and how to use it</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <section>
        <!-- Title slide -->
        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1><code>pathlib.Path</code></h1>
          <h2>Why and how to use it</h2>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            - Today I plan to convince you should stop representing your file paths as strings and starting using `Path` objects for *all* of your file paths
          </aside>
        </section>

        <!-- About me slide -->
        <section>
          <p class="fragment" data-fragment-index=3 style="margin-bottom: 1em; margin-top: -1em;"><a href="http://trey.io/news" style="color: #663399; font-weight: bold;">trey.io/news</a> ‚Äî  a weekly Python tip üíå</p>
          <div class="aboutme-card fragment" data-fragment-index=1>
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos" alt="Truthful Technology"></a>
          </div>
          <div class="aboutme-card fragment" data-fragment-index=2>
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos" alt="Python Morsels"></a>
          </div>
          <aside class="notes" data-markdown>
            - I help folks level-up their Python skills
            - I run both virtual and on-site Python workshops and courses for teams
            - And I run Python Morsels, which helps Python developers of all skill levels gradually deepen their Python skills through weekly practice
            - I also share a Python tip every week through my newsletter
            - If that sounds you're kind of thing, you can can signup at trey.io/news
          </aside>
        </section>
      </section>

      <!-- os, os.path, glob, shutil -->
      <section>

        <section>
          <h2>Problems with pathlib alternatives</h2>
          <ul style="list-style: none; font-size: 1.2em; line-height: 1.5;">
            <li>‚òê Utilities are difficult to find</li>
            <li>‚òê Utilities are awkward to use</li>
            <li>‚òê String paths are error-prone</li>
            <li>‚òê Hard to distinguish paths from other strings</li>
          </ul>
          <aside class="notes" data-markdown>
            - There are 4 reasons I recommend using pathlib:
              - The alternatives to pathlib are:
                - difficult to find
                - awkward to use
              - Representing file paths as strings:
                - requires deliberate effort for bug-free code
                - makes it harder to distinguish between a path and any other string
            - I'd like to address each of these before we take a look at pathlib
          </aside>
        </section>

        <section style="transform-origin: center center; transform: scale(1.1);">
          <div style="height: 600px; display: grid; grid-template-columns: 1fr 1fr 1fr;">
            <img src="left_shark.jpg" class="fragment no-style" style="margin: auto;" data-fragment-index=5>
            <img src="the_dress.jpg" class="fragment no-style" style="margin: auto;" data-fragment-index=4>
            <div style="position: relative; display: inline-block;" class="fragment" data-fragment-index=2>
            <img src="tiktok_logo.png" class="no-style" style="margin: auto; opacity: 0.8;">
            <!-- Red X overlay -->
            <div style="position: absolute; top: -10%; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0.8;">
                <!-- First diagonal line -->
                <div style="position: absolute; top: 50%; left: 0; width: 100%; height: 10px; background-color: red; transform: translateY(-50%) rotate(45deg); transform-origin: center;"></div>
                <!-- Second diagonal line -->
                <div style="position: absolute; top: 50%; left: 0; width: 100%; height: 10px; background-color: red; transform: translateY(-50%) rotate(-45deg); transform-origin: center;"></div>
            </div>
            </div>
            <img src="old_lateshow_colbert_logo.jpg" class="fragment no-style" style="margin: auto;" data-fragment-index=1>
            <img src="vine_wordmark.svg.png" class="fragment no-style" style="margin: auto;" data-fragment-index=3>
            <img src="pycon_2015.png" class="fragment no-style" style="margin: auto;" data-fragment-index=6>
          </div>
          <aside class="notes" data-markdown>
            - Let's hop in a time machine for a bit...
            - Let's roll the clock back by about 330 million seconds
            - The year is 2015
            - **(click)** The Late Show with Stephen Colbert had just premiered
            - TikTok didn't exist, but there was something called Vine
            - Everyone's arguing about whether the dress is black and blue or white and gold
            - And everyone was preparing their left shark Halloween costumes
            - And we... are still using Python 2.7, which won't be end-of-life'd for another 5 years
          </aside>
        </section>

        <section>
          <p><code>os</code></p>
          <p><code>os.path</code></p>
          <p><code>glob</code></p>
          <p><code>shutil</code></p>
          <aside class="notes" data-markdown>
            - When we need to work with file paths, we reach for one of these 4 standard library modules...
            - The `os` package
            - The `os.path` submodule
            - The `glob` module
            - And the `shutil` module
          </aside>
        </section>

        <section>
          <h1><code>shutil</code> module</h1>
          <p class="fragment highlight-red" data-fragment-index=1><code>copyfile(src, dst)</code>, <code>copyfileobj(fsrc, fdst)</code></p>
          <p class="fragment highlight-red" data-fragment-index=1><code>copy(src, dst)</code>, <code>copy2(src, dst)</code></p>
          <p class="fragment highlight-red" data-fragment-index=1><code>copymode(src, dst)</code>, <code>copystat(src, dst)</code></p>
          <p><code class="fragment highlight-red" data-fragment-index=1>copytree(src, dst)</code>, <code>move(src, dst)</code></p>
          <p><code>rmtree(path)</code></p>
          <p><code>chown(path, ...)</code></p>
          <aside class="notes" data-markdown>
            - The `shutil` has a bunch of high-level file-related stuff, including 7 different functions related to copying files
            - But representing file paths as strings can *also* be messy...
          </aside>
        </section>

        <section>
          <h1><code>glob</code> module</h1>
          <p><code>glob(pattern)</code></p>
          <p><code>iglob(pattern)</code></p>
          <p><code>escape(pathname)</code></p>
          <p><code>translate(pathname)</code></p>
          <aside class="notes" data-markdown>
            - The `glob` module is much simpler
            - There's `glob`, `iglob`, and 2 other functions
            - You'd use this module if you needed to find files based on a wildcard pattern
          </aside>
        </section>

        <section>
          <h1><code>os.path</code> module</h1>
          <p><code>normpath(name)</code>, <code>abspath(path)</code></p>
          <p><code>basename(path)</code>, <code>dirname(path)</code></p>
          <p><code>isfile(path)</code>, <code>isdir(path)</code></p>
          <p><code>splitext(path)</code>, <code>getsize(path)</code></p>
          <p><code>relpath(path, parent)</code>, <code>join(parent, name)</code></p>
          <aside class="notes" data-markdown>
            - The `os.path` module includes a bunch of utilites for manipulating file paths
            - Splitting file paths apart, joining them together, and asking questions of file paths
          </aside>
        </section>

        <section>
          <h1 class="fragment" data-fragment-index=2>Python's Junk Drawers</h1>
          <h2 style="display: inline; margin-right: 2em;"><code>os</code></h2>
          <h2 class="fragment" data-fragment-index=1 style="display: inline;"><code>sys</code></h2>
          <h3 class="fragment" data-fragment-index=2 style="margin-top: 1em;">üîëüñáÔ∏è‚úèÔ∏èüß∑</h3>
          <aside class="notes" data-markdown>
            - The `os` module is a bit more complicated than those other 3 modules...
            - The Python standard library has 2 modules **(click)**...
            - That act as *junk drawers* **(click)**: the `os` module and the `sys` module
            - The `sys` module is for stuff related to the Python interpreter that don't have a more appropriate home
            - The `os` module is for stuff generally related to your computer which doesn't have a more appropriate home
            - Python stores *a lot* of file-related stuff in the `os` module...
          </aside>
        </section>

        <section>
          <p><code>os.getcwd()</code>, <code>os.chdir()</code></p>
          <p><code>os.chmod()</code></p>
          <p><code>os.symlink()</code>, <code>os.link()</code>, <code>os.readlink()</code></p>
          <p><code>os.stat()</code>, <code>os.lstat()</code></p>
          <p><code>os.scandir()</code>, <code>os.walk()</code></p>
          <p><code>os.rename()</code>, <code>os.replace()</code>, <code>os.remove()</code></p>
          <p><code>os.mkdir()</code>, <code>os.makedirs()</code></p>
          <aside class="notes" data-markdown>
            - There are utilities for getting the current working directory and for changing it
            - For changing the modes of a file or directory
            - Stuff for working with both symbolic links and hard links
            - Utilities for traversing the file system
            - Utilities for renaming and replacing files
            - And utilities for making directories
            - These are most of the file-related utilities in Python's `os`
            - But this is *not* everything that's *in* the `os` module...
            - There's also all this...
          </aside>
        </section>

        <section>
          <p>
<code>os.abort()</code>,
<code>os.access()</code>,
<code>os.chown()</code>,
<code>os.chroot()</code>,
<code>os.close()</code>,
<code>os.closerange()</code>,
<code>os.confstr()</code>,
<code>os.copy_file_range()</code>,
<code>os.cpu_count()</code>,
<code>os.ctermid()</code>,
<code>os.device_encoding()</code>,
<code>os.dup()</code>,
<code>os.dup2()</code>,
<code>os.eventfd()</code>,
<code>os.eventfd_read()</code>,
<code>os.eventfd_write()</code>,
<code>os.execl()</code>,
<code>os.execle()</code>,
<code>os.execlp()</code>,
<code>os.execlpe()</code>,
<code>os.execv()</code>,
<code>os.execve()</code>,
<code>os.execvp()</code>,
<code>os.execvpe()</code>,
<code>os.fchdir()</code>,
<code>os.fchmod()</code>,
<code>os.fchown()</code>
          </p>
          <aside class="notes" data-markdown>
            - ...
            - And this...
          </aside>
        </section>

        <section>
          <p>
<code>os.fdatasync()</code>,
<code>os.fdopen()</code>,
<code>os.fork()</code>,
<code>os.forkpty()</code>,
<code>os.fpathconf()</code>,
<code>os.fsdecode()</code>,
<code>os.fsencode()</code>,
<code>os.fspath()</code>,
<code>os.fstat()</code>,
<code>os.fstatvfs()</code>,
<code>os.fsync()</code>,
<code>os.ftruncate()</code>,
<code>os.fwalk()</code>,
<code>os.get_blocking()</code>,
<code>os.get_exec_path()</code>,
<code>os.get_inheritable()</code>,
<code>os.get_terminal_size()</code>,
<code>os.getcwdb()</code>,
<code>os.getegid()</code>,
<code>os.getenv()</code>,
<code>os.getenvb()</code>,
<code>os.geteuid()</code>,
<code>os.getgid()</code>,
<code>os.getgrouplist()</code>,
<code>os.getgroups()</code>,
<code>os.getloadavg()</code>,
<code>os.getlogin()</code>,
<code>os.getpgid()</code>,
<code>os.getpgrp()</code>
          <aside class="notes" data-markdown>
            - ...
            - And this...
          </aside>
        </section>

        <section>
          <p>
<code>os.getpid()</code>,
<code>os.getppid()</code>,
<code>os.getpriority()</code>,
<code>os.getrandom()</code>,
<code>os.getresgid()</code>,
<code>os.getresuid()</code>,
<code>os.getsid()</code>,
<code>os.getuid()</code>,
<code>os.getxattr()</code>,
<code>os.grantpt()</code>,
<code>os.initgroups()</code>,
<code>os.isatty()</code>,
<code>os.kill()</code>,
<code>os.killpg()</code>,
<code>os.lchown()</code>,
<code>os.listdir()</code>,
<code>os.listxattr()</code>,
<code>os.lockf()</code>,
<code>os.login_tty()</code>,
<code>os.lseek()</code>,
<code>os.major()</code>,
<code>os.makedev()</code>,
<code>os.memfd_create()</code>,
<code>os.minor()</code>,
<code>os.mkfifo()</code>,
<code>os.mknod()</code>,
<code>os.nice()</code>,
<code>os.open()</code>,
<code>os.openpty()</code>,
<code>os.pathconf()</code>,
<code>os.pidfd_open()</code>
          <aside class="notes" data-markdown>
            - ...
            - and this...
          </aside>
        </section>

        <section>
          <p>
<code>os.pipe()</code>,
<code>os.pipe2()</code>,
<code>os.popen()</code>,
<code>os.posix_fadvise()</code>,
<code>os.posix_fallocate()</code>,
<code>os.posix_openpt()</code>,
<code>os.posix_spawn()</code>,
<code>os.posix_spawnp()</code>,
<code>os.pread()</code>,
<code>os.preadv()</code>,
<code>os.ptsname()</code>,
<code>os.putenv()</code>,
<code>os.pwrite()</code>,
<code>os.pwritev()</code>,
<code>os.read()</code>,
<code>os.readinto()</code>,
<code>os.readv()</code>,
<code>os.register_at_fork()</code>,
<code>os.remove()</code>,
<code>os.removedirs()</code>,
<code>os.removexattr()</code>,
<code>os.renames()</code>,
<code>os.rmdir()</code>
          <aside class="notes" data-markdown>
            - ...
            - *and*...
          </aside>
        </section>

        <section>
          <p>
<code>os.sched_get_priority_max()</code>,
<code>os.sched_get_priority_min()</code>,
<code>os.sched_getaffinity()</code>,
<code>os.sched_getparam()</code>,
<code>os.sched_getscheduler()</code>,
<code>os.sched_rr_get_interval()</code>,
<code>os.sched_setaffinity()</code>,
<code>os.sched_setparam()</code>,
<code>os.sched_setscheduler()</code>,
<code>os.sched_yield()</code>,
<code>os.sendfile()</code>,
<code>os.set_blocking()</code>,
<code>os.set_inheritable()</code>
          <aside class="notes" data-markdown>
            - This.
            - ...
            - Oh... and also...
          </aside>
        </section>

        <section>
          <p>
<code>os.setegid()</code>,
<code>os.seteuid()</code>,
<code>os.setgid()</code>,
<code>os.setgroups()</code>,
<code>os.setns()</code>,
<code>os.setpgid()</code>,
<code>os.setpgrp()</code>,
<code>os.setpriority()</code>,
<code>os.setregid()</code>,
<code>os.setresgid()</code>,
<code>os.setresuid()</code>,
<code>os.setreuid()</code>,
<code>os.setsid()</code>,
<code>os.setuid()</code>,
<code>os.setxattr()</code>,
<code>os.spawnl()</code>,
<code>os.spawnle()</code>,
<code>os.spawnlp()</code>,
<code>os.spawnlpe()</code>,
<code>os.spawnv()</code>,
<code>os.spawnve()</code>,
<code>os.spawnvp()</code>,
<code>os.spawnvpe()</code>,
<code>os.splice()</code>,
<code>os.statvfs()</code>,
<code>os.strerror()</code>,
<code>os.sync()</code>,
<code>os.sysconf()</code>,
<code>os.system()</code>,
<code>os.tcgetpgrp()</code>,
<code>os.tcsetpgrp()</code>
          <aside class="notes" data-markdown>
            - This.
            - ...
            - Plus this...
          </aside>
        </section>

        <section>
          <p>
<code>os.timerfd_create()</code>,
<code>os.timerfd_gettime()</code>,
<code>os.timerfd_gettime_ns()</code>,
<code>os.timerfd_settime()</code>,
<code>os.timerfd_settime_ns()</code>,
<code>os.times()</code>,
<code>os.truncate()</code>,
<code>os.ttyname()</code>,
<code>os.umask()</code>,
<code>os.uname()</code>,
<code>os.unlink()</code>,
<code>os.unlockpt()</code>,
<code>os.unsetenv()</code>,
<code>os.unshare()</code>,
<code>os.urandom()</code>,
<code>os.utime()</code>,
<code>os.wait()</code>,
<code>os.wait3()</code>,
<code>os.wait4()</code>,
<code>os.waitid()</code>,
<code>os.waitpid()</code>,
<code>os.waitstatus_to_exitcode()</code>,
<code>os.write()</code>,
<code>os.writev()</code>
          </p>
          <aside class="notes" data-markdown>
            - ...
            - *That* is everything in the `os` module
            - Well, that's all functions...
            - There are also dozens of constants... that I'm not going to show you
          </aside>
        </section>

        <section>
          <p><code>os.getcwd()</code>, <code>os.chdir()</code></p>
          <p><code>os.chmod()</code></p>
          <p><code>os.symlink()</code>, <code>os.link()</code>, <code>os.readlink()</code></p>
          <p><code>os.stat()</code>, <code>os.lstat()</code></p>
          <p><code>os.scandir()</code>, <code>os.walk()</code></p>
          <p><code>os.rename()</code>, <code>os.replace()</code>, <code>os.remove()</code></p>
          <p><code>os.mkdir()</code>, <code>os.makedirs()</code></p>
          <aside class="notes" data-markdown>
            - My point in dumping out the contents the `os` junk drawer
            - Is to point out how difficult it can be to *find* the dozen-ish file-related utilities that are *in* the `os` module
            - And these are just the utilities that live in the `os` module...
          </aside>
        </section>

        <section>
          <p style="font-size: 90%;">
          <code style="white-space: nowrap;">shutil.copy(src, dst)</code>, <code style="white-space: nowrap;">shutil.copy2(src, dst)</code>,
          <code style="white-space: nowrap;">shutil.copytree(src, dst)</code>, <code style="white-space: nowrap;">shutil.move(src, dst)</code>,
          <code>shutil.rmtree(path)</code>,
          <code>os.getcwd()</code>, <code>os.chdir()</code>,
          <code>os.chmod()</code>,
          <code>os.symlink()</code>, <code>os.link()</code>, <code>os.readlink()</code>,
          <code>os.stat()</code>,
          <code>os.scandir()</code>, <code>os.walk()</code>,
          <code>os.rename()</code>, <code>os.replace()</code>, <code>os.remove()</code>
          <code>os.mkdir()</code>, <code>os.makedirs()</code>,
          <code>os.path.abspath(path)</code>,
          <code>os.path.basename(path)</code>, <code>os.path.dirname(path)</code>,
          <code>os.path.isfile(path)</code>, <code>os.path.isdir(path)</code>,
          <code>os.path.splitext(path)</code>, <code>os.path.getsize(path)</code>,
          <code style="white-space: nowrap;">os.path.relpath(path, parent)</code>, <code style="white-space: nowrap;">os.path.join(parent, name)</code>,
          <code>glob.glob(pattern)</code>
          <aside class="notes" data-markdown>
            - These are *most* of the useful path-related utilities included in Python...
            - I removed about 10 less frequently used functions that didn't fit on this slide
            - Back in 2015, in Python 2.7, we *had* to go hunting for these utilities when needed them
          </aside>
        </section>

        <section>
          <h2>Problems with pathlib alternatives</h2>
          <ul style="list-style: none; font-size: 1.2em; line-height: 1.5;">
            <li style="color: #28a745;">‚òë Utilities are difficult to find</li>
            <li>‚òê Utilities are awkward to use</li>
            <li>‚òê String paths are error-prone</li>
            <li>‚òê Hard to distinguish paths from other strings</li>
          </ul>
          <aside class="notes" data-markdown>
            - So, the alternatives to pathlib are difficult to find
            - But do we even need all these utility functions?
          </aside>
        </section>

      </section>

      <!-- Why even use os.path? -->
      <section>

        <section>
          <pre class="python"><code data-trim data-noescape style="font-size: 95%">
import os.path

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
TEMPLATES_DIR = os.path.join(BASE_DIR, "templates")
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape style="font-size: 95%">
import os.path

BASE_DIR = os.path.abspath(__file__).rsplit("/", maxsplit=2)[0]
TEMPLATES_DIR = BASE_DIR  + "/templates"
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape style="font-size: 95%">
import os
import os.path

BASE_DIR = os.path.abspath(__file__).rsplit(os.sep, maxsplit=2)[0]
TEMPLATES_DIR = BASE_DIR  + os.sep + "templates"
          </code></pre>
          <aside class="notes" data-markdown>
            - This code sets `BASE_DIR` to the directory above the current file's directory
            - And it sets `TEMPLATES_DIR` to the templates subdirectory within that base directory
            - But these file paths are just strings...
            - So instead of using `os.path.dirname` and `os.path.join`, couldn't we just use the string `rsplit` method and string concatenation?
            - Well, this code *is* shorter, but it's probably buggy on Windows, which prefers backslashes as path separators instead of forward slashes
            - We *could* have relied on `os.sep` **(click)** to determine which path separator to use based on our operating system
            - But I think *this code* is *less readable* than version that used the `os.path` utilities
            - Also...
          </aside>
        </section>

        <section>
          <h3>Mixed slashes üò∞</h3>
          <pre class="python"><code data-trim data-noescape>
          C:\Documents\ever\seen/a path/like this.txt
          </code></pre>
          <aside class="notes" data-markdown>
            - depending on where our path came from, we might accidentally end up with a mix of forward slashes and back slashes, which is technically valid on Windows but it also looks really weird
            - When file paths are strings... there's a very real temptation to call string methods, use concatenation, and use string slicing
            - But performing string manipulations on path strings can get us in trouble
          </aside>
        </section>

        <section>
          <h2>Problems with pathlib alternatives</h2>
          <ul style="list-style: none; font-size: 1.2em; line-height: 1.5;">
            <li>‚òë Utilities are difficult to find</li>
            <li>‚òê Utilities are awkward to use</li>
            <li style="color: #28a745;">‚òë String paths are error-prone</li>
            <li>‚òê Hard to distinguish paths from other strings</li>
          </ul>
          <aside class="notes" data-markdown>
            - So using strings to represent paths can easily lead to bugs if we're very careful in the way we work those strings
          </aside>
        </section>

        <section>
          <h1><code>os.path</code> module</h1>
          <p><code>normpath(name)</code>, <code>abspath(path)</code></p>
          <p><code>basename(path)</code>, <code>dirname(path)</code></p>
          <p><code>isfile(path)</code>, <code>isdir(path)</code></p>
          <p><code>splitext(path)</code>, <code>getsize(path)</code></p>
          <p><code>relpath(path, parent)</code>, <code>join(parent, name)</code></p>
          <aside class="notes" data-markdown>
            - Python's various utilites for manipulating file paths *are* useful
            - But if we forget to use them, and instead treat our path strings just like any other string, it's easy to accidentally write buggy code that doesn't work across multiple operating systems
            - Potential bugs aren't the only issue though...
            - representing file paths as strings can be messy for other reasons...
          </aside>
        </section>

      </section>

      <!-- Stringly typed path code -->
      <section>
        <section>
          <h1>Stringly Typed Code</h1>
          <p class="fragment">passes strings around when a better type exists</p>
          <aside class="notes" data-markdown>
            - Stringly-typed code **(click)** is code that passes strings around when a *better* type exists
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
target = "2025-09-25"

if target[:4] == "2025":
    print("That's this year")
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
from datetime import datetime

user_input = "2025-09-25"
target = datetime.strptime(user_input, "%Y-%m-%d").date()

if target.year == 2025:
    print("That's this year")
          </code></pre>
          <aside class="notes" data-markdown>
            - This code is stringly-typed: it uses a string to represent a date
            - This code uses a `datetime.date` object to represent a `date` instead
            - I prefer this second block of code. It's a bit easier to work with date objects than with strings *and* we automatically get a bit more certainty about whether the data we're working with might be invalid.
          </aside>
        </section>

        <section>
          <h3><span class="fragment fade-out" data-fragment-index=1>The age-old tradition of path strings</span></h3>
          <pre class="python"><code data-trim data-noescape style="font-size: 95%">
import os.path

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
TEMPLATES_DIR = os.path.join(BASE_DIR, "templates")
          </code></pre>
          <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape style="font-size: 95%">
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
TEMPLATES_DIR = BASE_DIR / "templates"
          </code></pre>
          <aside class="notes" data-markdown>
            - As we've discussed, old Python code always used strings to represent file paths
            - ... I would argue that *this* is stringly-typed code
            - There is a *better way* to write this code **(click)**
            - ... using the `Path` class from Python's `pathlib` module
            - We'll address the differences between these 2 coding styles in a moment...
            - But first, I'd like to acknowledge the fact that using `Path` objects instead of a string makes it easier to distinguish between filenames and *any other* string
          </aside>
        </section>

        <section>
          <h3>Type annotation confusion</h3>
          <pre class="python"><code data-trim data-noescape>
from typing import Optional

# Are these meant to represent filenames or file contents?
question: Optional[str] = None
answer: Optional[str] = None

def find_editorconfig_file() -> str:
    ...  # Does this return a file path or file contents?
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
from pathlib import Path
from typing import Optional

question: Optional[Path] = None
answer: Optional[Path] = None

def find_editorconfig_file() -> Path:
    ...  #
          </code></pre>

          <aside class="notes" data-markdown>
            - If your code uses type annotations **(click)**, a file path might look just like any other string
            - Which can make it harder to catch path-related bugs
            - And it can make it harder to reason about your code
          </aside>
        </section>

        <section>
          <h2>Problems with pathlib alternatives</h2>
          <ul style="list-style: none; font-size: 1.2em; line-height: 1.5;">
            <li>‚òë Utilities are difficult to find</li>
            <li>‚òê Utilities are awkward to use</li>
            <li>‚òë String paths are error-prone</li>
            <li style="color: #28a745;">‚òë Hard to distinguish paths from other strings</li>
          </ul>
          <aside class="notes" data-markdown>
            - We've seen that the alternatives of pathlib of difficult to find, that path strings are error-prone, and that path strings also make it difficult to distinguish between paths and non-path strings
            - I'd like to quickly address my last point by comparison to pathlib...
          </aside>
        </section>

      </section>

      <!-- Awkward paths -->
      <section>

        <section>
          <h2>String paths versus <code>Path</code> objects</h2>
          <aside class="notes" data-markdown>
            - Let's compare the readability of code that represents strings as paths to the same code that uses `pathlib.Path` objects
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape style="font-size: 95%">
import os.path
BASE_DIR = <span class="fragment bold-current" data-fragment-index=3>os.path.dirname</span>(<span class="fragment bold-current" data-fragment-index=2>os.path.dirname</span>(<span class="fragment bold-current" data-fragment-index=1>os.path.abspath</span>(__file__)))
TEMPLATES_DIR = os.path.join(BASE_DIR, "templates")
          </code></pre>
          <pre class="python fragment" data-fragment-index=4><code data-trim data-noescape style="font-size: 95%">
from pathlib import Path
BASE_DIR = Path(__file__).<span class="fragment bold-current" data-fragment-index=5>resolve()</span>.<span class="fragment bold-current" data-fragment-index=6>parent</span>.<span class="fragment bold-current" data-fragment-index=7>parent</span><span class="fragment" data-fragment-index=8></span>
TEMPLATES_DIR = BASE_DIR / "templates"
          </code></pre>
          <aside class="notes" data-markdown>
            - This code was taken from a Django project...
            - And it represents paths using strings
            - I find that I need to read this code inside out: we get the absolute path **(click)**, then the parent directory **(click)**, and then get its parent directory. **(click)**
            - Instead of this code which uses strings for paths, I prefer **(click)** this code
            - This code represents paths using `pathlib.Path` objects
            - I read *this* from left-to-right: we **(click)** resolve the path into an absolute path, get **(click)** the parent directory, and get **(click)** its parent directory.
            - When using strings as paths, **(click)** we need to use nested function calls that, but when using `Path` objects we can use chained method calls and attribute accesses.
            - I think the pathlib version reads much more naturally
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
from os.path import isdir, join
from glob import iglob
# ...
if isdir(path):
    for path in <span class="fragment bold-current">iglob(join(path, "*.py"), recursive=True)</span>:
        if isfile(path):
            process_file(path)
else:
    process_file(path)
          </code></pre>
          <pre class="python"><code data-trim data-noescape>
from pathlib import Path
# ...
if path.is_dir():
    for path in <span class="fragment bold-current">path.rglob("*.py")</span>:
        if path.is_file():
            process_file(path)
else:
    results.append(process_file(path))<span class="fragment"></span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Here's another example comparing the `glob` module and `pathlib`
            - Instead of **(click)** joining a path and then passing it to `iglob`, with `pathlib` we can **(click)** just call the `rglob` method on that page
            - Shorter code **(click)** isn't *always* more readable, but when the shorter code has less noise it usually *is*
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
with open("config.txt", mode="rt") as file:
    content = file.read()
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
content = Path("config.txt").read_text()
          </code></pre>
          <aside class="notes" data-markdown>
            - I very often need to open a file, read the whole contents of the file into a string, and then close the file
            - With `pathlib`, there's a convenience method for that **(click)**
            - Instead of using the `open` function, we could just call the `read_text` method
          </aside>
        </section>

        <section>
          <table style="font-size: 0.6em; width: 100%;">
            <tr>
              <th>Task</th>
              <th>The old way</th>
              <th>The pathlib way</th>
            </tr>
            <tr>
              <td style="border: 0; font-size: 110%;">Make dir</td>
              <td style="border: 0;"><code>os.mkdir(path)</code></td>
              <td style="border: 0; vertical-align: middle;" rowspan="2"><code>path.mkdir(parents=True)</code></td>
            </tr>
            <tr>
              <td style="border: 0; font-size: 110%;">with parents</td>
              <td style="border: 0;"><code>os.makedirs(path)</code></td>
            </tr>
            <tr>
              <td style="border: 0; font-size: 110%;">Copy file</td>
              <td style="border: 0;"><code>shutil.copy(src, dst)</code></td>
              <td style="border: 0; vertical-align: middle;" rowspan="2"><code>path.copy_into(dst)</code><br><small>Python 3.14+</small></td>
            </tr>
            <tr>
              <td style="border: 0; font-size: 110%;">into dir</td>
              <td style="border: 0;"><code>shutil.copy(src, dst/filename)</code></td>
            </tr>
          </table>
          <aside class="notes" data-markdown>
            - The methods on the `pathlib.Path` class are a bit deliberately designed than many of the other path-related functions included in Python
            - For example, compare the `pathlib.Path` class's `mkdir` method to its alternatives...
            - If you wanted to make a directory without `pathlib`, you would use either `os.mkdir` *or* `os.makedirs`, depending on whether you wanted to parent directories
            - The `mkdir` method on `Path` objects *includes* the ability to make missing parent directories, thanks to the optional `parents` keyword argument
            - The new `copy` method that `Path` objects are getting in Python 3.14 is another great example...
            - In Python 3.14, the pathlib.Path class will have a `copy` method and a `copy_into` method
            - The `copy` method is for copying files or directories to a new location whereas the `copy_into` method is for copying them *into* a different directory
            - These 2 methods existed, you needed to reach for either `shutil.copyfile`, `shutil.copy`, `shutil.copy2`, or `shutil.copytree`... all 4 of these have slightly different uses and I always needed to read the documentation to figure out which one I needed
          </aside>
        </section>

        <section>
          <h2>Problems with pathlib alternatives</h2>
          <ul style="list-style: none; font-size: 1.2em; line-height: 1.5;">
            <li>‚òë Utilities are difficult to find</li>
            <li style="color: #28a745;">‚òë  Utilities are awkward to use</li>
            <li>‚òë String paths are error-prone</li>
            <li>‚òë Hard to distinguish paths from other strings</li>
          </ul>
          <aside class="notes" data-markdown>
            - So code that uses pathlib is often more readable than the alternative
          </aside>
        </section>

      </section>

      <!-- Python supports a better way -->
      <section>
        <section>
          <h2>How does it work?</h2>
          <aside class="notes" data-markdown>
            - So `pathlib` can improve the readability of code that uses file paths
            - But how does `pathlib` actually work?
          </aside>
        </section>

        <section>
          <h3>It's all about <code>Path</code> objects</h3>
          <pre class="python"><code data-trim data-noescape>
>>> from pathlib import Path
>>> <span class="fragment">path = Path(".editorconfig")
>>> </span><span class="fragment">path
PosixPath('.editorconfig')
</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Well, the `pathlib` module contains pretty much one thing: a class called `Path`
            - So to understanding `pathlib` means understanding `Path` objects and the `Path` class
            - The `Path` class accepts a string which represents a file path and returns a new `Path` object
            - The `Path` object you get will either be a `PosixPath` or a `WindowsPath`, depending on the operating system that the code is running on
            - Both types support all the same features, but they normalize paths differently
            - You don't need to worry about any of that because the `Path` object you get should work the way you'd expect it to on the operating system you're using
          </aside>
        </section>

        <section>
          <p style="font-size: 90%; font-family: monospace;">
          <span class="fragment bold-current" data-fragment-index=1>
          <code>p.chmod()</code>,
          <code>p.copy()</code>,
          <code>p.copy_into()</code>,
          <code>p.exists()</code>,
          <code>p.expanduser()</code>,
          <code>p.glob()</code>,
          <code>p.is_dir()</code>,
          <code>p.is_file()</code>,
          <code>p.iterdir()</code>,
          <code>p.mkdir()</code>,
          <code>p.move()</code>,
          <code>p.move_into()</code>,
          <code>p.read_text()</code>,
          <code>p.rename()</code>,
          <code>p.replace()</code>,
          <code>p.resolve()</code>,
          <code>p.rglob()</code>,
          <code>p.rmdir()</code>,
          <code>p.stat()</code>,
          <code>p.unlink()</code>,
          <code>p.walk()</code>,
          <code>p.write_text()</code>,
          <code>p.joinpath()</code>,
          <code>p.relative_to()</code>,
          <code>p.with_name()</code>,
          <code>p.with_stem()</code>,
          <code>p.with_suffix()</code>,
          </span>
          <span class="fragment bold-current" data-fragment-index=3>
          <code>Path.cwd()</code>,
          <code>Path.home()</code>,
          </span>
          <span class="fragment bold-current" data-fragment-index=2>
          <code>p.name</code>,
          <code>p.parent</code>,
          <code>p.parents</code>,
          <code>p.parts</code>,
          <code>p.stem</code>,
          <code>p.suffix</code>
          </span>
          </p>
          <aside class="notes" data-markdown>
            - This is pretty all of the useful features that the `Path` class supports
            - Most of these are **(click)** methods that you can call on individual `Path` objects
            - Some of these are **(click)** attributes of the `Path` objects
            - And 2 of these are **(click)** class methods: one returns the current working directory and the other returns the user's home directory
            - Technically these are only about *half* of the 70-ish methods and attributes...
          </aside>
        </section>

        <section>
          <p style="font-size: 90%; font-family: monospace;">
          <code>p.absolute()</code>,
          <code>p.as_uri()</code>,
          <code>p.is_fifo()</code>,
          <code>p.group()</code>,
          <code>p.hardlink_to()</code>,
          <code>p.is_block_device()</code>,
          <code>p.is_char_device()</code>,
          <code>p.is_junction()</code>,
          <code>p.is_mount()</code>,
          <code>p.is_socket()</code>,
          <code>p.is_symlink()</code>,
          <code>p.lchmod()</code>,
          <code>p.lstat()</code>,
          <code>p.open()</code>,
          <code>p.owner()</code>,
          <code>p.readlink()</code>,
          <code>p.read_bytes()</code>,
          <code>p.samefile()</code>,
          <code>p.symlink_to()</code>,
          <code>p.touch()</code>,
          <code>p.write_bytes()</code>,
          <code>Path.from_uri()</code>,
          <code>p.as_posix()</code>,
          <code>p.is_absolute()</code>,
          <code>p.is_relative_to()</code>,
          <code>p.is_reserved()</code>,
          <code>p.full_match()</code>,
          <code>p.match()</code>,
          <code>p.with_segments()</code>,
          <code>p.anchor</code>,
          <code>p.drive</code>,
          <code>p.root</code>,
          <code>p.suffixes</code>
          </p>
          <aside class="notes" data-markdown>
            - These are the rest of the methods and attributes
            - ... but I don't find myself using these ones very often
          </aside>
        </section>

        <section>
          <pre class="python fragment"><code data-trim data-noescape>
path = Path("example.txt")
with open(<span class="fragment bold">str(path)</span>) as f:
    content = f.read()
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
path = Path("example.txt")
with open(<strong>path</strong>) as f:
    content = f.read()</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - So `Path` objects have lots of useful features built-in...
            - But what happens when you actually want to *use* a `Path` object as a file path?
            - Back when `pathlib` was first added to Python, **(click)** in order to actually *use* a `Path` object, you might have needed **(click)** to convert the `Path` to a string...
            - Today, that's completely unnecessary...
            - Because Python's built-in `open` function accepts `Path` objects
            - In fact... pretty much *every* utility in Python that accepts a file path as a string will *also* accept a `Path` object...
          </aside>
        </section>

        <section>
          <h3><code>pathlib</code> works everywhere you need it</h3>
          <p><code>os.chdir()</code></p>
          <p><code>shutil.chown()</code></p>
          <p><code>sqlite3.connect()</code></p>
          <p><code>logging.FileHandler()</code></p>
          <p><code>zipfile.ZipFile()</code></p>
          <p><code>subprocess.run()</code></p>
          <aside class="notes" data-markdown>
            - Whether you need to:
              - change directories
              - change the ownership of a file
              - connect to a sqlite database
              - log to a file
              - create a ZIP file
              - or run a subprocess
            - ...you can use `pathlib.Path` objects instead of using path strings...
            - You don't need to convert Path objects back to strings
            - Every standard library function that *should* accept `Path` object, does
            - In fact even standard library utilities that are specifically designed for a path strings will also work with `Path` objects...
          </aside>
        </section>

        <section>
          <h3>It even works legacy utilities</h3>
          <p><code>os.path.abspath()</code></p>
          <p><code>os.path.isfile()</code></p>
          <p><code>os.path.join()</code></p>
          <p><code>os.remove()</code></p>
          <p><code>os.mkdir()</code></p>
          <p><code>shutil.copy()</code></p>
          <p><code>shutil.move()</code></p>
          <aside class="notes" data-markdown>
            - If you're still using `os.path` functions, that's okay...
            - All of these functions accept `pathlib.Path` objects
          </aside>
        </section>

        <section>
          <p style="font-size: 90%;">
          <code style="white-space: nowrap;">shutil.copy(src, dst)</code>, <code style="white-space: nowrap;">shutil.copy2(src, dst)</code>,
          <code style="white-space: nowrap;">shutil.copytree(src, dst)</code>, <code style="white-space: nowrap;">shutil.move(src, dst)</code>,
          <code>shutil.rmtree(path)</code>,
          <code>os.chmod()</code>,
          <code>os.symlink()</code>, <code>os.link()</code>, <code>os.readlink()</code>,
          <code>os.stat()</code>,
          <code>os.scandir()</code>, <code>os.walk()</code>,
          <code>os.rename()</code>, <code>os.replace()</code>, <code>os.remove()</code>
          <code>os.mkdir()</code>, <code>os.makedirs()</code>,
          <code>os.path.abspath(path)</code>,
          <code>os.path.basename(path)</code>, <code>os.path.dirname(path)</code>,
          <code>os.path.isfile(path)</code>, <code>os.path.isdir(path)</code>,
          <code>os.path.splitext(path)</code>, <code>os.path.getsize(path)</code>,
          <code style="white-space: nowrap;">os.path.relpath(path, parent)</code>, <code style="white-space: nowrap;">os.path.join(parent, name)</code>
          </p>
          <aside class="notes" data-markdown>
            - Every path-related tool we saw earlier that *accepts* a file path string will also accept a `pathlib.Path` object...
            - So you can *usually* pass `Path` objects to legacy code that was written *without* `pathlib` in mind and it will *often* just work
          </aside>
        </section>

        <section>
          <h3>Third-party libraries support <code>Path</code> objects</h3>
          <div>
            <p><code>django</code> (in <code>settings</code> for example)</p>
            <p><code>pandas.read_csv(path)</code></p>
            <p><code>PIL.Image.open(path)</code></p>
            <p><code>pytest.main([path])</code></p>
            <p><code>click.File()(path)</code></p>
          </div>
          <aside class="notes" data-markdown>
            - TODO
            - Even most third-party libraries that handle file paths will usually *also* accept `pathlib.Path` objects...
            - Django, pandas, pillow, pytest, and click all support `Path` objects
            - Most modern Python libraries work just fine with `pathlib`
          </aside>
        </section>
      </section>

      <!-- Okay, but how? -->
      <section>
        <section>
          <h2>Okay, but how?</h2>
          <aside class="notes" data-markdown>
            - So `pathlib` is great...
            - But in practice, how can you start using `pathlib`?
          </aside>
        </section>

        <section>
          <h3>Creating <code>Path</code> objects</h3>
          <pre class="python"><code data-trim data-noescape>
>>> from pathlib import Path
>>> <span class="fragment">notes_path = Path("Documents/notes.txt")
>>> </span><span class="fragment">notes_path
WindowsPath('documents/notes.txt')
>>> </span><span class="fragment">notes_path2 = Path(r"documents\notes.txt")
>>> </span><span class="fragment">notes_path2
WindowsPath('documents/notes.txt')
>>> </span><span class="fragment">notes_path2 == notes_path
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Pretty much anytime you encounter a string that represents a file path **(click)**, you'll pass that string to the `Path` class to get `Path` object **(click)**
            - When you're writing cross-platform compatible code, you'll want to use forward slashes in the string literals you pass to `pathlib.Path`
            - ... but don't worry about backslashes on Windows! **(click)**
            - If you end up with a backslash-separated path on a Windows machine, pathlib will normalize it automatically! **(click)**
            - On Windows, this path with backslash separators will be interpreted **(click)** the same way as *this* path with forward slash separators
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
<span class="fragment">>>> from pathlib import Path
>>> home = Path.home()
>>> </span><span class="fragment">path1 = home.joinpath(".config.toml")
>>> </span><span class="fragment">path2 = home / ".config.toml"
>>> </span><span class="fragment">path3 = Path(home, ".config.toml")
>>> </span><span class="fragment">path3
PosixPath('/home/trey/.config.toml')
>>> </span><span class="fragment">path1 == path2 == path3
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Once you have a `Path` object, there are lots of things you can do with it
            - If your `Path` object represents a directory, you may end up joining your path with a filename
            - There are multiple ways to join paths with `pathlib`
            - There's a `joinpath` **(click)**
            - And `Path` objects also overload the `/` operator
            - Which looked a bit odd to me at first, but now that I'm used to it, I find this pretty readable
            - Also, the `Path` class can accept multiple arguments to join together... and those arguments can be either strings or other `Path` objects
            - So this joins our home directory path with this config filename
            - All 3 of these approaches return equivalent `Path` objects
            - And neither of these is necessarily better than the others
            - Although, you'll usually only see that third approach used if we're not sure whether `home` is a `Path` object or a string
          </aside>
        </section>

        <section>
          <h3>Consolidated functionality</h3>
          <table style="font-size: 0.75em; width: 100%;">
            <tr>
              <th>pathlib</th>
              <th>Traditional approach</th>
              <th>Returns</th>
            </tr>
            <tr>
              <td><code>Path(name)</code></td>
              <td><code>os.path.normpath(name)</code></td>
              <td><code>Path</code></td>
            </tr>
            <tr>
              <td><code>path.resolve()</code></td>
              <td><code>os.path.abspath(path)</code></td>
              <td><code>Path</code></td>
            </tr>
            <tr>
              <td><code>path.name</code></td>
              <td><code>os.path.basename(path)</code></td>
              <td><code>str</code></td>
            </tr>
            <tr>
              <td><code>path.parent</code></td>
              <td><code>os.path.dirname(path)</code></td>
              <td><code>Path</code></td>
            </tr>
            <tr>
              <td><code>path.suffix</code></td>
              <td><code>os.path.splitext(path)[1]</code></td>
              <td><code>str</code></td>
            </tr>
            <tr>
              <td><code>path.is_file()</code></td>
              <td><code>os.path.isfile(path)</code></td>
              <td><code>bool</code></td>
            </tr>
            <tr>
              <td><code>parent / name</code></td>
              <td><code>os.path.join(parent, name)</code></td>
              <td><code>Path</code></td>
            </tr>
          </table>
          <aside class="notes" data-markdown>
            - I always found the functions in `os.path` to be unfortunately named...
            - Lots of shortened words all squashed together...
            - With pathlib, all the same functionality exists as either methods or attributes on `Path` objects
            - And they're all pretty well-named
          </aside>
        </section>

        <section>
          <h3>Gradual adoption</h3>
          <pre class="python"><code data-trim data-noescape>
# Start by converting at function boundaries
def process_config(config_path):
    path = Path(config_path)  # Works with strings OR Path objects
    return path.read_text()

# Legacy code still works
old_function("/path/to/config.txt")
new_function(Path("config.txt"))

# Mix and match as you migrate
for filename in os.listdir(directory):
    file_path = Path(directory) / filename  # pathlib joining
    if file_path.suffix == '.py':           # pathlib properties
        with open(file_path) as f:          # builtin functions accept Path
            content = f.read()
          </code></pre>
          <p class="fragment">The Path class accepts strings <em>and</em> other Path objects</p>
          <aside class="notes" data-markdown>
            - TODO
            - Something that's pretty great about `pathlib` is that you *can* gradually adopt `pathlib`
            - Path objects *should* work everywhere string paths work
            - And you can use the built-in `Path` class to make sure that the path you're working is a `Path` object and not a string
            - Just as you can pass a any iterable to the built-in `list` function to turn it into a `list`, including the `list` type, you can also pass pass either strings *or* `Path` objects to the `Path` class to make sure you're working with a `Path` object
          </aside>
        </section>

        <!--
        <section>
          <h3>Using <code>pathlib.Path</code> with <code>argparse</code></h3>
          <pre class="python"><code data-trim data-noescape style="font-size: 90%">
# For immediate file opening:
parser.add_argument("input", type=argparse.FileType("r"))
# args.input is already an open file object

<span class="fragment"># For flexible path handling:
parser.add_argument("path", type=Path)
# args.path is a Path object

if args.path.is_dir():
    ...  # Directory given
elif args.path.is_file():
    ...  # Existing file given
else:
    ...  # Path doesn't represent a file or a directory!</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO Two different approaches for different use cases
            - FileType for immediate opening
            - Path type for flexible path handling
          </aside>
        </section>
        -->

      </section>

      <!-- This isn't just about pathlib -->
      <section>
        <section>
          <h2>This isn't just about <code>pathlib</code></h2>
          <aside class="notes" data-markdown>
            - This talk *is* about pathlib... but it isn't *just* about pathlib
            - Code that uses `pathlib` can also work with code that *inherits* from `pathlib.Path`...
            - *And* it's also possible to practice *duck tying* when it comes to path objects
          </aside>
        </section>

        <section>
          <h3>Extending <code>pathlib.Path</code></h3>
          <pre class="python"><code data-trim data-noescape style="font-size: 85%">
import os
import pathlib

class BetterPath(pathlib.Path):
    def chdir(self):
        os.chdir(self)
        return self.cwd()
          </code></pre>
          <p class="fragment">Python 3.12+ officially supports pathlib inheritance</p>
          <aside class="notes" data-markdown>
            - Since Python 3.12, you can extend the functionality of `pathlib` through inheritance
            - If you'd like to make your own `Path` objects that include a method to change directories, you can!
            - You'll just inherit from `pathlib.Path` and then use your own custom `BetterPath` class the same way you'd use the `pathlib.Path` class
          </aside>
        </section>

        <section>
          <h3>More extension examples</h3>
          <pre class="python"><code data-trim data-noescape style="font-size: 75%">
# Add common_prefix functionality
class BetterPath(pathlib.Path):
    def common_prefix(self, other):
        return self.with_segments(os.path.commonprefix((self, other)))

<span class="fragment"># Enhanced rmdir with recursive option
class BetterPath(pathlib.Path):
    def rmdir(self, *, recursive=False, ignore_errors=False):
        if recursive:
            shutil.rmtree(self, ignore_errors=ignore_errors)
        else:
            try:
                super().rmdir()
            except Exception:
                if not ignore_errors:
                    raise</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If you wanted to add a `common_prefix` method because you miss that function from `os.path`, you can make your own `Path` class that has it!
            - You can also enhance the functionality of *existing* methods
            - For example, if you wanted to allow the `rmdir` method to delete non-empty directories, you could override the `rmdir` method
            - Note the `with_segments` method call in that `common_prefix` method...
            - That's the way for subclasses of `Path` to return new `Path` objects of the *same* type
            - But that method can *also* be helpful to override...
          </aside>
        </section>

        <section>
          <pre class="python fragment" data-fragment-index=2><code data-trim data-noescape style="font-size: 70%">
>>> git_path = GitPath("src/main.py", repo_root=".")
>>> <span class="fragment" data-fragment-index=3>git_path.parent  # repo_root is preserved when creating new paths
GitPath('/home/user/project/src', <span class="fragment bold" data-fragment-index=4>repo_root='/home/user/project')</span></span>
          </code></pre>
          <pre class="python"><code data-trim data-noescape style="font-size: 70%">
class GitPath(pathlib.Path):
    def __init__(self, *segments, repo_root):
        super().__init__(*segments)
        self.repo_root = pathlib.Path(repo_root).resolve()

    def <span class="fragment bold" data-fragment-index=1>with_segments</span>(self, *args):
        """Ensure any derived paths remember the repo root."""
        return type(self)(*args, repo_root=self.repo_root)

    def relative_to_repo(self):
        return self.relative_to(self.repo_root or self.root)

    def __repr__(self):
        return f"{type(self).__name__}({str(self)!r}, repo_root={self.repo_root!r})"
          </code></pre>
          <aside class="notes" data-markdown>
            - If you need to attach metadata to a custom `Path` object, you can override the `with_segments` method **(click)** to ensure that your metadata is preserved for *any* `Path` that's *derived* from an existing `Path`
            - Whether we're joining a new path onto ours or getting a parent directory **(click)**, that `repo_root` attribute **(click)** will be maintained on the new `GitPath` objects that are generated
            - This pattern makes it pretty easy to make specialized `Path` subclasses
          </aside>
        </section>

        <section>
          <h3>Third-party alternatives with PEP 519</h3>
          <aside class="notes" data-markdown>
            - TODO add code example!
            - When you learned that you can loop over a list in Python, you were learning something about lists, but you were *also* learning something about *iterables*
            - When we learned about all the different Python utilities that accept `pathlib.Path` objects... we *also* learning about `Path`-like objects
            - `pathlib` is part of a larger ecosystem
          </aside>
        </section>

        <section>
          <h1>PEP 519</h1>
          <ul>
            <li class="fragment">Defines the <code>os.PathLike</code> protocol</li>
            <li class="fragment">Built-in functions like <code>open()</code> accept path-like objects</li>
            <li class="fragment">Any object with a <code>__fspath__()</code> method works</li>
            <li class="fragment">Enables third-party path-like</li>
            <li class="fragment">Third-party libraries use <code>os.fspath()</code> paths to strings</li>
          </ul>
          <aside class="notes" data-markdown>
            - PEP 519 defines the Path-like protocol
            - All Path-like objects are accepted by `open`, and all other built-in path tools
            - The only that's needed for a Path-like object is a `__fspath__` method
            - That method will make an object work with all of Python's many path-accepting functions
            - And any third-party utility that wants to convert a Path-like object into a string can use the `os.fspath` function to do so
            - This PEP allows for a whole ecosystem of Path-like objects beyond just `pathlib`
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
import os

class MyPath:
    def __init__(self, path):
        self.path = os.fspath(path)
    
    def __fspath__(self):
        return self.path

# Any object with __fspath__ works with open()
my_path = MyPath("example.txt")
with open(my_path) as f:
    content = f.read()
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO add transitions to code
            - For example, here's a class called `MyPath` which *does not* inherit from `pathlib.Path`
            - And yet, this class *works* with the built-in `open` function
            - You probably won't want to make own your `Path` object scompletely from scratch, but you might use a third-party library that *does*
          </aside>
        </section>

        <section>
          <h3>Real third-party example: plumbum</h3>
          <pre class="python"><code data-trim data-noescape>
from plumbum import local

# This is a plumbum Path, not a pathlib Path
my_file = local.path("example.txt")

# But it works with open() because it has __fspath__
with open(my_file) as f:
    content = f.read()

# It also works with os.path functions
import os.path
print(os.path.exists(my_file))  # Works!
          </code></pre>
          <aside class="notes" data-markdown>
            - For example, the plumbum library has a Path class that works differently from pathlib's `Path` class, but it has `__fspath__` method...
            - Which means, it also work with the built-in `open` function!
            - Thanks to this PEP 519, there are `pathlib` alternatives that works just as well as `pathlib` does
          </aside>
        </section>

      </section>

      <!-- pathlib anti-patterns -->
      <section>
        <section>
          <h2>pathlib anti-patterns</h2>
          <aside class="notes" data-markdown>
            - Before we conclude, I'd like to make sure to discuss a couple common mistakes that new `pathlib` users often make
          </aside>
        </section>

        <section>
          <h3>Using the <code>open</code> method</h3>
          <pre class="python"><code data-trim data-noescape>
path = Path("example.txt")
with <span class="fragment bold">path.open()</span> as file:
    contents = file.read()
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
path = Path("example.txt")
with <strong>open(path)</strong> as file:
    contents = file.read()</span>
          </code></pre>
          <p class="fragment">The <code>open</code> method is a relic from an earlier time</p>
          <aside class="notes" data-markdown>
            - The `Path` class has an `open` method
            - Back in Python 3.5, the `open` method was the official way to get an open file out of a `Path` object
            - The Path-like interfaces was added in Python 3.6 thanks to PEP 519, so now `Path` objects work with the built-in `open` function
            - There is no reason to use the `open` method anymore
            - The `open` method only exists because there were 2 versions of Python that included `pathlib`, before the `open` function worked with `pathlib`
            - So I recommend *against* the `open` method
          </aside>
        </section>

        <section>
          <h3>Unnecessary string conversion</h3>
          <pre class="python"><code data-trim data-noescape>
path = Path("example.txt")
with open(<span class="fragment bold">str(path)</span>) as f:
    content = f.read()
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
path = Path("example.txt")
with open(path) as f:
    content = f.read()</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Also, don't convert `Path` objects to strings
            - ... at least, not unless you really need to
            - Sometimes I'll convert a `Path` to a string implicitly by using it in a `print` call or in an f-string...
            - But only because I'm displaying the path to and end user or logging it to a file
            - If you think you need to convert a `Path` object to a string, you probably don't
          </aside>
        </section>

        <section>
          <h3>Better Path constructor usage</h3>
          <pre class="python"><code data-trim data-noescape>
<span class="fragment">config = Path(directory).joinpath(".editorconfig")</span>
<span class="fragment">config = Path(directory) / ".editorconfig"</span>
<span class="fragment">config = Path(directory, ".editorconfig")</span>
          </code></pre>
          <p class="fragment">Works whether <code>directory</code> is a string or Path object</p>
          <aside class="notes" data-markdown>
            - Also, don't forget that the `Path` constructor can accept multiple arguments
            - So if you have a directory string and a file string and you'd like to join them together, you need to make a `Path` object and then use `joinpath` or the `/` operator...
            - You can just pass both of your strings to the `Path` class
            - This even works if you're not sure whether one of these is already a `Path` object...
          </aside>
        </section>

      </section>

      <!-- Outro -->
      <section>
        <section>
          <h2>Use <code>pathlib</code>. You won't regret it.</h2>
          <ul>
            <li class="fragment">Cross-platform compatibility built-in</li>
            <li class="fragment">High-level APIs for common operations</li>
            <li class="fragment">Easier type-checking</li>
            <li class="fragment">More readable code</li>
          </ul>
          <aside class="notes" data-markdown>
            - So with pathlib...
            - It's easy to write path-handling code that works on all operating systems
            - Common operations are made even simpler than they were
            - You get to avoid awkward stringly-typed code
            - And your code will probably both more readable and easier to maintain
            - But... there's a very common concern I hear about pathlib, that I feel is unwarranted...
          </aside>
        </section>

        <section>
          <h3>"But <code>pathlib</code> is slow"</h3>
          <p class="fragment">Yes, it can be slower for some operations</p>
          <p class="fragment">400,000 files searched</p>
          <p class="fragment">0.91 seconds with <code>os.walk()</code></p>
          <p class="fragment">0.85 seconds with <code>pathlib.Path().walk()</code></p>
          <p class="fragment">2.22 seconds when converting back to <code>pathlib.Path()</code></p>
          <p class="fragment"><strong>Don't optimize parts of your code that aren't bottlenecks</strong></p>
          <aside class="notes" data-markdown>
            - pathlib is slow
            - It *is* true that `pathlib` can be slower for *some* operations... **(click)**
            - But readability is sometimes worth a small performance penaltiy
            - I searched 4 hundred thousand files **(click)** with `os.walk` **(click)** and with the `pathlib` `walk` method **(click)**
            - And `pathlib` wasn't any slower...
            - Except, the `walk` method returns strings, which is a bit of cheat...
            - When I converted all 4 hundred thousand paths back into `Path` objects in order to ask questions of them...
            - My code slowed down
            - Although, unless I'm actually planning to process many thousands of files, this kind of slow down is *probably* insignificant
            - Most path operations **aren't in tight loops**
            - Readability is usually more important than micro-optimizations
            - Use the right tool for the right job.
            - Optimize only when it really matters.
          </aside>
        </section>

        <section>
          <h1>pathlib</h1>
          <p style="font-size: 1.5em;"><q>just another way to represent paths</q></p>
          <p style="font-size: 1.5em;" class="fragment"><q>the ideal way to represent file paths</q></p>
          <aside class="notes" data-markdown>
            - pathlib isn't just a different API
            - It's about representing file paths *properly*
          </aside>
        </section>

        <!-- Thank you slide -->
        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h2 style="margin-top: 1.5em;">Thanks!</h2>
          <h3><a href="http://trey.io/pathlib">trey.io/pathlib</a></h3>
          <div style="margin-top: 2.5em;">
            <p style="float: left; margin-right: 2em;">
              <strong>Trey Hunner</strong><br>
              <small>Python Team Trainer</small>
            </p>
            <p style="float: left;">
            <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
            <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
            </p>
          </div>
          <aside class="notes" data-markdown>
            - TODO Thank you for your attention!
            - Questions?
          </aside>
        </section>
      </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>


    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/title-footer/title-footer.js', async: true, callback: function() {
            title_footer.initialize("trey.io/pybeach2025", "rgba(0,255,0,0.0)");
          } }
        ]
      });
      if (window.self !== window.top) {
        document.body.className += " notes";
      }
    </script>
  </body>
</html>
